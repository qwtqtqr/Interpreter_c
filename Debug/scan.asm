; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_05OODBEKIG@while@				; `string'
PUBLIC	??_C@_03MEPDGFMA@var@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8478A1A4_tokens@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__8DC84CAD_corecrt_wtime@h DB 01H
__CF01F9AA_time@h DB 01H
__56B56370_scan@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var@
CONST	SEGMENT
??_C@_03MEPDGFMA@var@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while@
CONST	SEGMENT
??_C@_05OODBEKIG@while@ DB 'while', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_next
PUBLIC	_putback
PUBLIC	_skip
PUBLIC	_scan_tokens
PUBLIC	_chrpos
PUBLIC	_scanIntAndFloat
PUBLIC	_scanident
PUBLIC	_createFinalString
PUBLIC	_createNewString
PUBLIC	_scanChars
PUBLIC	_scan_curToken
PUBLIC	_skip_comments
PUBLIC	_putBack_curToken
PUBLIC	_keyword
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@ ; `string'
PUBLIC	??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@ ; `string'
PUBLIC	??_C@_0L@FPFMPDDA@0123456789@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	__real@4024000000000000
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_newLinkedList:PROC
EXTRN	_LinkedList_add_end:PROC
EXTRN	_LinkedList_size:PROC
EXTRN	_LinkedList_getNode:PROC
EXTRN	_strchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_pow:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	__ftol2:PROC
EXTRN	__ltod3:PROC
EXTRN	_Text:BYTE
EXTRN	_Line:DWORD
EXTRN	_Putback:DWORD
EXTRN	_Infile:DWORD
EXTRN	_currentToken:DWORD
EXTRN	_globl_putback_token:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FPFMPDDA@0123456789@
CONST	SEGMENT
??_C@_0L@FPFMPDDA@0123456789@ DB '0123456789', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
CONST	SEGMENT
??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@ DB '[ER'
	DB	'ROR] unknown token in Line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@
CONST	SEGMENT
??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@ DB '['
	DB	'SYNTAX ERROR]  a ''%c'' is missing (Line %d)', 0aH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@
CONST	SEGMENT
??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@ DB 'identifier t'
	DB	'oo long line %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_multicharTokens DD FLAT:??_C@_05IJDJACGD@print@
	DD	07H
	DD	FLAT:??_C@_02HEBPBKGD@if@
	DD	08H
	DD	FLAT:??_C@_05OODBEKIG@while@
	DD	0eH
	DD	FLAT:??_C@_03MEPDGFMA@var@
	DD	014H
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	015H
	DD	FLAT:??_C@_04LOAJBDKD@true@
	DD	01fH
	DD	FLAT:??_C@_05LAPONLG@false@
	DD	020H
_singleCharTokens DD 02bH
	DD	00H
	DD	02dH
	DD	01H
	DD	02aH
	DD	02H
	DD	02fH
	DD	03H
	DD	05eH
	DD	04H
	DD	03bH
	DD	06H
	DD	028H
	DD	09H
	DD	029H
	DD	0aH
	DD	07bH
	DD	0bH
	DD	07dH
	DD	0cH
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_cmp_operators
_TEXT	SEGMENT
tv64 = -208						; size = 4
_c$ = -8						; size = 4
_c_$ = 8						; size = 4
_scan_cmp_operators PROC				; COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 122  : 	int c = c_;

	mov	eax, DWORD PTR _c_$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 123  : 	switch (c)

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 33					; 00000021H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 91			; 0000005bH
	ja	$LN2@scan_cmp_o
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN17@scan_cmp_o[edx]
	jmp	DWORD PTR $LN18@scan_cmp_o[eax*4]
$LN4@scan_cmp_o:

; 124  : 	{
; 125  : 	case '=':
; 126  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 127  : 		if (c == '=')

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	jne	SHORT $LN5@scan_cmp_o

; 128  : 		{
; 129  : 			return TT_EQUALS_CMP;

	mov	eax, 22					; 00000016H
	jmp	$LN16@scan_cmp_o
$LN5@scan_cmp_o:

; 130  : 		}
; 131  : 
; 132  : 		putback(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_putback
	add	esp, 4

; 133  : 		return TT_EQUALS;

	mov	eax, 19					; 00000013H
	jmp	$LN16@scan_cmp_o
$LN6@scan_cmp_o:

; 134  : 
; 135  : 	case '!':
; 136  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 137  : 		if (c == '=')

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	jne	SHORT $LN7@scan_cmp_o

; 138  : 		{
; 139  : 			return TT_NOT_EQUALS;

	mov	eax, 26					; 0000001aH
	jmp	$LN16@scan_cmp_o
$LN7@scan_cmp_o:

; 140  : 		}
; 141  : 		printf("[ERROR] unknown token in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
	call	_printf
	add	esp, 8

; 142  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@scan_cmp_o:

; 143  : 
; 144  : 	case '>':
; 145  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 146  : 		if (c == '=')

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	jne	SHORT $LN9@scan_cmp_o

; 147  : 		{
; 148  : 			return TT_GREATER_EQUALS;

	mov	eax, 29					; 0000001dH
	jmp	$LN16@scan_cmp_o
$LN9@scan_cmp_o:

; 149  : 		}
; 150  : 		putback(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_putback
	add	esp, 4

; 151  : 		return TT_GREATER;

	mov	eax, 27					; 0000001bH
	jmp	$LN16@scan_cmp_o
$LN10@scan_cmp_o:

; 152  : 
; 153  : 	case '<':
; 154  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 155  : 		if (c == '=')

	cmp	DWORD PTR _c$[ebp], 61			; 0000003dH
	jne	SHORT $LN11@scan_cmp_o

; 156  : 		{
; 157  : 			return TT_SMALLER_EQUALS;

	mov	eax, 30					; 0000001eH
	jmp	$LN16@scan_cmp_o
$LN11@scan_cmp_o:

; 158  : 		}
; 159  : 		putback(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_putback
	add	esp, 4

; 160  : 		return TT_SMALLER;

	mov	eax, 28					; 0000001cH
	jmp	SHORT $LN16@scan_cmp_o
$LN12@scan_cmp_o:

; 161  : 
; 162  : 	case '&':
; 163  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 164  : 		if (c == '&')

	cmp	DWORD PTR _c$[ebp], 38			; 00000026H
	jne	SHORT $LN13@scan_cmp_o

; 165  : 		{
; 166  : 			return TT_AND;

	mov	eax, 23					; 00000017H
	jmp	SHORT $LN16@scan_cmp_o
$LN13@scan_cmp_o:

; 167  : 		}
; 168  : 		printf("[ERROR] unknown token in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
	call	_printf
	add	esp, 8

; 169  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@scan_cmp_o:

; 170  : 
; 171  : 	case '|':
; 172  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 173  : 		if (c == '|')

	cmp	DWORD PTR _c$[ebp], 124			; 0000007cH
	jne	SHORT $LN15@scan_cmp_o

; 174  : 		{
; 175  : 			return TT_OR;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN16@scan_cmp_o
$LN15@scan_cmp_o:

; 176  : 		}
; 177  : 		printf("[ERROR] unknown token in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
	call	_printf
	add	esp, 8

; 178  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@scan_cmp_o:

; 179  : 
; 180  : 	}
; 181  : 	return -1;

	or	eax, -1
$LN16@scan_cmp_o:

; 182  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@scan_cmp_o:
	DD	$LN6@scan_cmp_o
	DD	$LN12@scan_cmp_o
	DD	$LN10@scan_cmp_o
	DD	$LN4@scan_cmp_o
	DD	$LN8@scan_cmp_o
	DD	$LN14@scan_cmp_o
	DD	$LN2@scan_cmp_o
$LN17@scan_cmp_o:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_scan_cmp_operators ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _keyword
_TEXT	SEGMENT
_retVal_ident$ = -56					; size = 8
_retVal$1 = -40						; size = 8
_curToken$2 = -24					; size = 8
_i$3 = -8						; size = 4
_s$ = 8							; size = 4
_keyword PROC						; COMDAT

; 42   : struct keyword_returnVal keyword(char* s) {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 43   : 	for (size_t i = 0; i < arraySize(multicharTokens); i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@keyword
$LN2@keyword:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@keyword:
	cmp	DWORD PTR _i$3[ebp], 7
	jae	SHORT $LN3@keyword

; 44   : 	{
; 45   : 		struct TokenIdent curToken = multicharTokens[i];

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _multicharTokens[eax*8]
	mov	edx, DWORD PTR _multicharTokens[eax*8+4]
	mov	DWORD PTR _curToken$2[ebp], ecx
	mov	DWORD PTR _curToken$2[ebp+4], edx

; 46   : 
; 47   : 		if (!strcmp(s, curToken.tokenStr))

	mov	eax, DWORD PTR _curToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@keyword

; 48   : 		{
; 49   : 			struct keyword_returnVal retVal = { curToken.tokenType, NULL };

	mov	eax, DWORD PTR _curToken$2[ebp+4]
	mov	DWORD PTR _retVal$1[ebp], eax
	mov	DWORD PTR _retVal$1[ebp+4], 0

; 50   : 			return (retVal);

	mov	eax, DWORD PTR _retVal$1[ebp]
	mov	edx, DWORD PTR _retVal$1[ebp+4]
	jmp	SHORT $LN1@keyword
$LN5@keyword:

; 51   : 		}
; 52   : 	}

	jmp	SHORT $LN2@keyword
$LN3@keyword:

; 53   : 	struct keyword_returnVal retVal_ident = { TT_IDENT, s };

	mov	DWORD PTR _retVal_ident$[ebp], 18	; 00000012H
	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _retVal_ident$[ebp+4], eax

; 54   : 	return retVal_ident;

	mov	eax, DWORD PTR _retVal_ident$[ebp]
	mov	edx, DWORD PTR _retVal_ident$[ebp+4]
$LN1@keyword:

; 55   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@keyword
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN11@keyword:
	DD	3
	DD	$LN10@keyword
$LN10@keyword:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN7@keyword
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN8@keyword
	DD	-56					; ffffffc8H
	DD	8
	DD	$LN9@keyword
$LN9@keyword:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN8@keyword:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$LN7@keyword:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_keyword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _putBack_curToken
_TEXT	SEGMENT
_token$ = 8						; size = 4
_putBack_curToken PROC					; COMDAT

; 185  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 186  : 	globl_putback_token = token;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR _globl_putback_token, eax

; 187  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_putBack_curToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _skip_comments
_TEXT	SEGMENT
_c$ = -8						; size = 4
_c_$ = 8						; size = 4
_skip_comments PROC					; COMDAT

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 310  : 	int c = c_;

	mov	eax, DWORD PTR _c_$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 311  : 	if (c == '/')

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN1@skip_comme

; 312  : 	{
; 313  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 314  : 		if (c == '/')

	cmp	DWORD PTR _c$[ebp], 47			; 0000002fH
	jne	SHORT $LN1@skip_comme
$LN2@skip_comme:

; 315  : 		{
; 316  : 			while (c != '\n' && c != EOF)

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN1@skip_comme
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN1@skip_comme

; 317  : 			{
; 318  : 				c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 319  : 			}

	jmp	SHORT $LN2@skip_comme
$LN1@skip_comme:

; 320  : 		}
; 321  : 	}
; 322  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_skip_comments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_curToken
_TEXT	SEGMENT
$T1 = -464						; size = 24
_valPtr$2 = -240					; size = 4
_val$3 = -225						; size = 1
_charT$ = -216						; size = 2
_string_final$4 = -204					; size = 4
_strList$5 = -192					; size = 4
_keyword_tt$6 = -180					; size = 4
_cur_key_ret_val$7 = -168				; size = 8
_floatValPtr$8 = -152					; size = 4
_floatVal$9 = -140					; size = 8
_intValPtr$10 = -124					; size = 4
_intVal$11 = -112					; size = 8
_numTT$12 = -96						; size = 4
_numStruct$13 = -84					; size = 24
_cmp_op$ = -52						; size = 4
_curIdent$14 = -40					; size = 8
_i$15 = -24						; size = 4
_c$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_scan_curToken PROC					; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 328  : 
; 329  : 	if (globl_putback_token != NULL)

	cmp	DWORD PTR _globl_putback_token, 0
	je	SHORT $LN5@scan_curTo

; 330  : 	{
; 331  : 		currentToken = globl_putback_token;

	mov	eax, DWORD PTR _globl_putback_token
	mov	DWORD PTR _currentToken, eax

; 332  : 		globl_putback_token = NULL;

	mov	DWORD PTR _globl_putback_token, 0

; 333  : 		return;

	jmp	$LN18@scan_curTo
$LN5@scan_curTo:

; 334  : 	}
; 335  : 
; 336  : 	int c = skip();

	call	_skip
	mov	DWORD PTR _c$[ebp], eax

; 337  : 	skip_comments(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_skip_comments
	add	esp, 4

; 338  : 
; 339  : 	if (c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN6@scan_curTo

; 340  : 	{
; 341  : 		currentToken = newToken(TT_EOF, 0, Line, NULL);

	push	0
	mov	eax, DWORD PTR _Line
	push	eax
	push	0
	push	0
	push	17					; 00000011H
	call	_newToken
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax
$LN6@scan_curTo:

; 342  : 	}
; 343  : 	for (size_t i = 0; i < arraySize(singleCharTokens); i++)

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN4@scan_curTo
$LN2@scan_curTo:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN4@scan_curTo:
	cmp	DWORD PTR _i$15[ebp], 10		; 0000000aH
	jae	SHORT $LN3@scan_curTo

; 344  : 	{
; 345  : 		struct TokenIdent curIdent = singleCharTokens[i];

	mov	eax, DWORD PTR _i$15[ebp]
	mov	ecx, DWORD PTR _singleCharTokens[eax*8]
	mov	edx, DWORD PTR _singleCharTokens[eax*8+4]
	mov	DWORD PTR _curIdent$14[ebp], ecx
	mov	DWORD PTR _curIdent$14[ebp+4], edx

; 346  : 		if (curIdent.tokenStr == c)

	mov	eax, DWORD PTR _curIdent$14[ebp]
	cmp	eax, DWORD PTR _c$[ebp]
	jne	SHORT $LN7@scan_curTo

; 347  : 		{
; 348  : 			currentToken = newToken(curIdent.tokenType, 0, Line, NULL);

	push	0
	mov	eax, DWORD PTR _Line
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _curIdent$14[ebp+4]
	push	ecx
	call	_newToken
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax

; 349  : 			putback(' ');

	push	32					; 00000020H
	call	_putback
	add	esp, 4

; 350  : 			return;

	jmp	$LN18@scan_curTo
$LN7@scan_curTo:

; 351  : 		}
; 352  : 	}

	jmp	SHORT $LN2@scan_curTo
$LN3@scan_curTo:

; 353  : 
; 354  : 	int cmp_op = scan_cmp_operators(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_scan_cmp_operators
	add	esp, 4
	mov	DWORD PTR _cmp_op$[ebp], eax

; 355  : 	if (cmp_op != -1)

	cmp	DWORD PTR _cmp_op$[ebp], -1
	je	SHORT $LN8@scan_curTo

; 356  : 	{
; 357  : 		currentToken = newToken(cmp_op, 0, Line, NULL);

	push	0
	mov	eax, DWORD PTR _Line
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _cmp_op$[ebp]
	push	ecx
	call	_newToken
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax

; 358  : 		return;

	jmp	$LN18@scan_curTo
$LN8@scan_curTo:

; 359  : 
; 360  : 	}
; 361  : 
; 362  : 	if (isdigit(c))

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	$LN9@scan_curTo

; 363  : 	{
; 364  : 		struct NumericVal numStruct = scanIntAndFloat(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	_scanIntAndFloat
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _numStruct$13[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _numStruct$13[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _numStruct$13[ebp+8], edx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _numStruct$13[ebp+12], ecx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _numStruct$13[ebp+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _numStruct$13[ebp+20], eax

; 365  : 		int numTT = numStruct.tokenType;

	mov	eax, DWORD PTR _numStruct$13[ebp+16]
	mov	DWORD PTR _numTT$12[ebp], eax

; 366  : 
; 367  : 		if (numTT == TT_INT)

	cmp	DWORD PTR _numTT$12[ebp], 5
	jne	SHORT $LN11@scan_curTo

; 368  : 		{
; 369  : 			INT_VAL intVal = numStruct.intVal;

	mov	eax, DWORD PTR _numStruct$13[ebp]
	mov	DWORD PTR _intVal$11[ebp], eax
	mov	ecx, DWORD PTR _numStruct$13[ebp+4]
	mov	DWORD PTR _intVal$11[ebp+4], ecx

; 370  : 			long long* intValPtr = malloc(sizeof(long long));

	mov	esi, esp
	push	8
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _intValPtr$10[ebp], eax

; 371  : 			*intValPtr = intVal;

	mov	eax, DWORD PTR _intValPtr$10[ebp]
	mov	ecx, DWORD PTR _intVal$11[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _intVal$11[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 372  : 
; 373  : 			currentToken = newToken(TT_INT, intVal, Line, new_DATA_STRUCT(NULL, NULL, NULL, intValPtr, NULL, DT_INT, 1));

	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _intValPtr$10[ebp]
	cdq
	push	edx
	push	eax
	push	0
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	mov	eax, DWORD PTR _Line
	push	eax
	mov	ecx, DWORD PTR _intVal$11[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _intVal$11[ebp]
	push	edx
	push	5
	call	_newToken
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax
$LN11@scan_curTo:

; 374  : 		}
; 375  : 		if (numTT == TT_FLOAT)

	cmp	DWORD PTR _numTT$12[ebp], 16		; 00000010H
	jne	SHORT $LN12@scan_curTo

; 376  : 		{
; 377  : 			double floatVal = numStruct.floatVal;

	movsd	xmm0, QWORD PTR _numStruct$13[ebp+8]
	movsd	QWORD PTR _floatVal$9[ebp], xmm0

; 378  : 			long double* floatValPtr = malloc(sizeof(long double));

	mov	esi, esp
	push	8
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _floatValPtr$8[ebp], eax

; 379  : 			*floatValPtr = floatVal;

	mov	eax, DWORD PTR _floatValPtr$8[ebp]
	movsd	xmm0, QWORD PTR _floatVal$9[ebp]
	movsd	QWORD PTR [eax], xmm0

; 380  : 			currentToken = newToken_float(TT_FLOAT, floatVal, Line, new_DATA_STRUCT(NULL, NULL, floatValPtr, NULL, NULL, DT_FLOAT, 1));

	push	1
	push	2
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _floatValPtr$8[ebp]
	push	eax
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _Line
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _floatVal$9[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	16					; 00000010H
	call	_newToken_float
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax
$LN12@scan_curTo:

; 381  : 		}
; 382  : 	}

	jmp	$LN16@scan_curTo
$LN9@scan_curTo:

; 383  : 
; 384  : 	else if (isalpha(c) || c == '_')

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@scan_curTo
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	jne	$LN16@scan_curTo
$LN14@scan_curTo:

; 385  : 	{
; 386  : 
; 387  : 		scanident(c, Text, TEXTLEN);

	push	512					; 00000200H
	push	OFFSET _Text
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_scanident
	add	esp, 12					; 0000000cH

; 388  : 		struct keyword_returnVal cur_key_ret_val = keyword(Text);

	push	OFFSET _Text
	call	_keyword
	add	esp, 4
	mov	DWORD PTR _cur_key_ret_val$7[ebp], eax
	mov	DWORD PTR _cur_key_ret_val$7[ebp+4], edx

; 389  : 		int keyword_tt = cur_key_ret_val.TokenType;

	mov	eax, DWORD PTR _cur_key_ret_val$7[ebp]
	mov	DWORD PTR _keyword_tt$6[ebp], eax

; 390  : 		if (keyword_tt != TT_IDENT)

	cmp	DWORD PTR _keyword_tt$6[ebp], 18	; 00000012H
	je	SHORT $LN15@scan_curTo

; 391  : 		{
; 392  : 			currentToken = newToken(keyword_tt, 0, Line, NULL);

	push	0
	mov	eax, DWORD PTR _Line
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _keyword_tt$6[ebp]
	push	ecx
	call	_newToken
	add	esp, 20					; 00000014H
	mov	DWORD PTR _currentToken, eax
$LN15@scan_curTo:

; 393  : 		}
; 394  : 		if (keyword_tt == TT_IDENT)

	cmp	DWORD PTR _keyword_tt$6[ebp], 18	; 00000012H
	jne	SHORT $LN16@scan_curTo

; 395  : 		{
; 396  : 			currentToken = newToken_identToken(TT_IDENT, Line, cur_key_ret_val.ident_name, 0, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _cur_key_ret_val$7[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _Line
	push	ecx
	push	18					; 00000012H
	call	_newToken_identToken
	add	esp, 24					; 00000018H
	mov	DWORD PTR _currentToken, eax
$LN16@scan_curTo:

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	if (c == '"')

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	jne	$LN17@scan_curTo

; 401  : 	{
; 402  : 		LinkedList* strList = newLinkedList();

	call	_newLinkedList
	mov	DWORD PTR _strList$5[ebp], eax

; 403  : 		createNewString(c, strList);

	mov	eax, DWORD PTR _strList$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_createNewString
	add	esp, 8

; 404  : 		char* string_final = createFinalString(strList);

	mov	eax, DWORD PTR _strList$5[ebp]
	push	eax
	call	_createFinalString
	add	esp, 4
	mov	DWORD PTR _string_final$4[ebp], eax

; 405  : 		currentToken = newToken_str(TT_STRING, 0, Line, string_final, new_DATA_STRUCT(string_final, NULL, NULL, NULL, NULL, DT_STRING, 1));

	push	1
	push	4
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _string_final$4[ebp]
	push	eax
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _string_final$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _Line
	push	edx
	push	0
	push	0
	push	13					; 0000000dH
	call	_newToken_str
	add	esp, 24					; 00000018H
	mov	DWORD PTR _currentToken, eax

; 406  : 
; 407  : 		free(strList);

	mov	esi, esp
	mov	eax, DWORD PTR _strList$5[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@scan_curTo:

; 408  : 	}
; 409  : 
; 410  : 	char charT[] = "'";

	mov	ax, WORD PTR ??_C@_01GEODFPGF@?8@
	mov	WORD PTR _charT$[ebp], ax

; 411  : 	if (c == charT[0])

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _charT$[ebp+ecx]
	cmp	DWORD PTR _c$[ebp], edx
	jne	SHORT $LN18@scan_curTo

; 412  : 	{
; 413  : 		char val = scanChars(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_scanChars
	add	esp, 4
	mov	BYTE PTR _val$3[ebp], al

; 414  : 		char* valPtr = malloc(sizeof(char));

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _valPtr$2[ebp], eax

; 415  : 		*valPtr = val;

	mov	eax, DWORD PTR _valPtr$2[ebp]
	mov	cl, BYTE PTR _val$3[ebp]
	mov	BYTE PTR [eax], cl

; 416  : 		currentToken = newToken_str(TT_CHAR, 0, Line, val, new_DATA_STRUCT(NULL, NULL, NULL, NULL, valPtr, DT_CHAR, 1));

	push	1
	push	3
	mov	eax, DWORD PTR _valPtr$2[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	movsx	ecx, BYTE PTR _val$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _Line
	push	edx
	push	0
	push	0
	push	15					; 0000000fH
	call	_newToken_str
	add	esp, 24					; 00000018H
	mov	DWORD PTR _currentToken, eax
$LN18@scan_curTo:

; 417  : 	}
; 418  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@scan_curTo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN25@scan_curTo:
	DD	4
	DD	$LN24@scan_curTo
$LN24@scan_curTo:
	DD	-40					; ffffffd8H
	DD	8
	DD	$LN20@scan_curTo
	DD	-84					; ffffffacH
	DD	24					; 00000018H
	DD	$LN21@scan_curTo
	DD	-168					; ffffff58H
	DD	8
	DD	$LN22@scan_curTo
	DD	-216					; ffffff28H
	DD	2
	DD	$LN23@scan_curTo
$LN23@scan_curTo:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	84					; 00000054H
	DB	0
$LN22@scan_curTo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$LN21@scan_curTo:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN20@scan_curTo:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_scan_curToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanChars
_TEXT	SEGMENT
_c$ = 8							; size = 4
_scanChars PROC						; COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 292  : 	c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 293  : 	next();

	call	_next

; 294  : 	return c;

	mov	al, BYTE PTR _c$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_scanChars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _createNewString
_TEXT	SEGMENT
_bufferCount$ = -44					; size = 4
_buff$ = -32						; size = 4
_curStrBuffIdx$ = -20					; size = 4
_strStartLine$ = -8					; size = 4
_c$ = 8							; size = 4
_buffList$ = 12						; size = 4
_createNewString PROC					; COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 60   : 	int strStartLine = Line;

	mov	eax, DWORD PTR _Line
	mov	DWORD PTR _strStartLine$[ebp], eax

; 61   : 	c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 62   : 	int curStrBuffIdx = 0;

	mov	DWORD PTR _curStrBuffIdx$[ebp], 0

; 63   : 	char* buff = calloc(STRINGBUFF_LEN, sizeof(char));

	mov	esi, esp
	push	1
	push	512					; 00000200H
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buff$[ebp], eax

; 64   : 	int bufferCount = 1;

	mov	DWORD PTR _bufferCount$[ebp], 1
$LN2@createNewS:

; 65   : 
; 66   : 
; 67   : 	while (c != '"' && c != EOF)

	cmp	DWORD PTR _c$[ebp], 34			; 00000022H
	je	SHORT $LN3@createNewS
	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN3@createNewS

; 68   : 	{
; 69   : 		buff[curStrBuffIdx] = c;

	mov	eax, DWORD PTR _buff$[ebp]
	add	eax, DWORD PTR _curStrBuffIdx$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl

; 70   : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 71   : 		curStrBuffIdx++;

	mov	eax, DWORD PTR _curStrBuffIdx$[ebp]
	add	eax, 1
	mov	DWORD PTR _curStrBuffIdx$[ebp], eax

; 72   : 		if (curStrBuffIdx == STRINGBUFF_LEN)

	cmp	DWORD PTR _curStrBuffIdx$[ebp], 512	; 00000200H
	jne	SHORT $LN4@createNewS

; 73   : 		{
; 74   : 			LinkedList_add_end(buffList, (char*)buff, 0, 0, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffList$[ebp]
	push	ecx
	call	_LinkedList_add_end
	add	esp, 20					; 00000014H

; 75   : 			buff = calloc(STRINGBUFF_LEN, sizeof(char));

	mov	esi, esp
	push	1
	push	512					; 00000200H
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _buff$[ebp], eax

; 76   : 			curStrBuffIdx = 0;

	mov	DWORD PTR _curStrBuffIdx$[ebp], 0

; 77   : 			bufferCount++;

	mov	eax, DWORD PTR _bufferCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _bufferCount$[ebp], eax
$LN4@createNewS:

; 78   : 		}
; 79   : 	}

	jmp	SHORT $LN2@createNewS
$LN3@createNewS:

; 80   : 	LinkedList_add_end(buffList, (char*)buff, 0, 0, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _buff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffList$[ebp]
	push	ecx
	call	_LinkedList_add_end
	add	esp, 20					; 00000014H

; 81   : 	if (c == EOF)

	cmp	DWORD PTR _c$[ebp], -1
	jne	SHORT $LN6@createNewS

; 82   : 	{
; 83   : 		printf("[SYNTAX ERROR]  a '%c' is missing (Line %d)\n ", '"', strStartLine);

	mov	eax, DWORD PTR _strStartLine$[ebp]
	push	eax
	push	34					; 00000022H
	push	OFFSET ??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@
	call	_printf
	add	esp, 12					; 0000000cH

; 84   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@createNewS:

; 85   : 	}
; 86   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_createNewString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _createFinalString
_TEXT	SEGMENT
_curChar$1 = -77					; size = 1
_c$2 = -68						; size = 4
_curBuffer$3 = -56					; size = 4
_listNode$ = -44					; size = 4
_curIdx$ = -32						; size = 4
_returnString$ = -20					; size = 4
_size$ = -8						; size = 4
_strBufferList$ = 8					; size = 4
_createFinalString PROC					; COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 90   : 	size_t size = (size_t)LinkedList_size(strBufferList) * STRINGBUFF_LEN + 1;

	mov	eax, DWORD PTR _strBufferList$[ebp]
	push	eax
	call	_LinkedList_size
	add	esp, 4
	shl	eax, 9
	add	eax, 1
	mov	DWORD PTR _size$[ebp], eax

; 91   : 	char* returnString = calloc(size, sizeof(char));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _returnString$[ebp], eax

; 92   : 
; 93   : 	int curIdx = 0;

	mov	DWORD PTR _curIdx$[ebp], 0

; 94   : 
; 95   : 	node_t* listNode = LinkedList_getNode(strBufferList, 0);

	push	0
	mov	eax, DWORD PTR _strBufferList$[ebp]
	push	eax
	call	_LinkedList_getNode
	add	esp, 8
	mov	DWORD PTR _listNode$[ebp], eax
$LN2@createFina:

; 96   : 	while (listNode != NULL)

	cmp	DWORD PTR _listNode$[ebp], 0
	je	SHORT $LN3@createFina

; 97   : 	{
; 98   : 		char* curBuffer = (char*)listNode->data;

	mov	eax, DWORD PTR _listNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curBuffer$3[ebp], ecx

; 99   : 		for (int c = 0; c < STRINGBUFF_LEN; c++)

	mov	DWORD PTR _c$2[ebp], 0
	jmp	SHORT $LN6@createFina
$LN4@createFina:
	mov	eax, DWORD PTR _c$2[ebp]
	add	eax, 1
	mov	DWORD PTR _c$2[ebp], eax
$LN6@createFina:
	cmp	DWORD PTR _c$2[ebp], 512		; 00000200H
	jge	SHORT $LN5@createFina

; 100  : 		{
; 101  : 			char curChar = *(curBuffer + c);

	mov	eax, DWORD PTR _curBuffer$3[ebp]
	add	eax, DWORD PTR _c$2[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _curChar$1[ebp], cl

; 102  : 			returnString[curIdx] = curChar;

	mov	eax, DWORD PTR _returnString$[ebp]
	add	eax, DWORD PTR _curIdx$[ebp]
	mov	cl, BYTE PTR _curChar$1[ebp]
	mov	BYTE PTR [eax], cl

; 103  : 			if (c < STRINGBUFF_LEN - 1)

	cmp	DWORD PTR _c$2[ebp], 511		; 000001ffH
	jge	SHORT $LN7@createFina

; 104  : 			{
; 105  : 				if (curChar == '\0')

	movsx	eax, BYTE PTR _curChar$1[ebp]
	test	eax, eax
	jne	SHORT $LN7@createFina

; 106  : 				{
; 107  : 					return returnString;

	mov	eax, DWORD PTR _returnString$[ebp]
	jmp	SHORT $LN1@createFina
$LN7@createFina:

; 108  : 				}
; 109  : 			}
; 110  : 			curIdx++;

	mov	eax, DWORD PTR _curIdx$[ebp]
	add	eax, 1
	mov	DWORD PTR _curIdx$[ebp], eax

; 111  : 		}

	jmp	SHORT $LN4@createFina
$LN5@createFina:

; 112  : 		listNode = listNode->next;

	mov	eax, DWORD PTR _listNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _listNode$[ebp], ecx

; 113  : 	}

	jmp	SHORT $LN2@createFina
$LN3@createFina:

; 114  : 	returnString[curIdx + 1] = '\0';

	mov	eax, DWORD PTR _returnString$[ebp]
	add	eax, DWORD PTR _curIdx$[ebp]
	mov	BYTE PTR [eax+1], 0

; 115  : 	return returnString;

	mov	eax, DWORD PTR _returnString$[ebp]
$LN1@createFina:

; 116  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_createFinalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanident
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = 8							; size = 4
_buf$ = 12						; size = 4
_lim$ = 16						; size = 4
_scanident PROC						; COMDAT

; 11   : int scanident(int c, char* buf, int lim) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 12   : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN2@scanident:

; 13   : 
; 14   : 	// Allow digits, alpha and underscores
; 15   : 	while (isalpha(c) || isdigit(c) || '_' == c) {

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@scanident
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@scanident
	cmp	DWORD PTR _c$[ebp], 95			; 0000005fH
	jne	SHORT $LN3@scanident
$LN4@scanident:

; 16   : 		// Error if we hit the identifier length limit,
; 17   : 		// else append to buf[] and get next character
; 18   : 		if (lim - 1 == i) {

	mov	eax, DWORD PTR _lim$[ebp]
	sub	eax, 1
	cmp	eax, DWORD PTR _i$[ebp]
	jne	SHORT $LN5@scanident

; 19   : 			printf("identifier too long line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@
	call	_printf
	add	esp, 8

; 20   : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp

; 21   : 		}

	jmp	SHORT $LN6@scanident
$LN5@scanident:

; 22   : 		else if (i < lim - 1) {

	mov	eax, DWORD PTR _lim$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN6@scanident

; 23   : 			buf[i++] = c;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@scanident:

; 24   : 		}
; 25   : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 26   : 	}

	jmp	SHORT $LN2@scanident
$LN3@scanident:

; 27   : 	// We hit a non-valid character, put it back.
; 28   : 	// NUL-terminate the buf[] and return the length
; 29   : 	putback(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_putback
	add	esp, 4

; 30   : 	buf[i] = '\0';

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	BYTE PTR [eax], 0

; 31   : 	return (i);

	mov	eax, DWORD PTR _i$[ebp]
$LN8@scanident:

; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_scanident ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanIntAndFloat
_TEXT	SEGMENT
tv243 = -380						; size = 8
_intStruct$ = -176					; size = 24
_floatStruct$1 = -144					; size = 24
_floatVal$2 = -112					; size = 8
_divNum$3 = -96						; size = 8
_firstNum$ = -80					; size = 4
_dotPos$ = -68						; size = 4
_count$ = -56						; size = 4
_isFloat$ = -44						; size = 4
_k$ = -32						; size = 8
_val$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
$T4 = 8							; size = 4
_c$ = 12						; size = 4
_scanIntAndFloat PROC					; COMDAT

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 95					; 0000005fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 237  : 	INT_VAL val = 0;

	xorps	xmm0, xmm0
	movlpd	QWORD PTR _val$[ebp], xmm0

; 238  : 	INT_VAL k;
; 239  : 
; 240  : 	int isFloat = 0;

	mov	DWORD PTR _isFloat$[ebp], 0

; 241  : 	int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 242  : 	int dotPos = -1;

	mov	DWORD PTR _dotPos$[ebp], -1

; 243  : 	int firstNum = 9;

	mov	DWORD PTR _firstNum$[ebp], 9
$LN2@scanIntAnd:

; 244  : 	while ((k = chrpos("0123456789", c)) >= 0 || c == '.') {

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@FPFMPDDA@0123456789@
	call	_chrpos
	add	esp, 8
	cdq
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _k$[ebp+4], edx
	cmp	DWORD PTR _k$[ebp+4], 0
	jg	SHORT $LN4@scanIntAnd
	jl	SHORT $LN12@scanIntAnd
	cmp	DWORD PTR _k$[ebp], 0
	jae	SHORT $LN4@scanIntAnd
$LN12@scanIntAnd:
	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	jne	SHORT $LN3@scanIntAnd
$LN4@scanIntAnd:

; 245  : 		if (count == 0)

	cmp	DWORD PTR _count$[ebp], 0
	jne	SHORT $LN5@scanIntAnd

; 246  : 		{
; 247  : 			firstNum = (int)k;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _firstNum$[ebp], eax
$LN5@scanIntAnd:

; 248  : 		}
; 249  : 		count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 250  : 		if (c == '.')

	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	jne	SHORT $LN6@scanIntAnd

; 251  : 		{
; 252  : 			isFloat = 1;

	mov	DWORD PTR _isFloat$[ebp], 1

; 253  : 			dotPos = count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _dotPos$[ebp], eax
$LN6@scanIntAnd:

; 254  : 		}
; 255  : 		if (c != '.')

	cmp	DWORD PTR _c$[ebp], 46			; 0000002eH
	je	SHORT $LN7@scanIntAnd

; 256  : 		{
; 257  : 			val = val * 10 + k;

	push	0
	push	10					; 0000000aH
	mov	eax, DWORD PTR _val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	__allmul
	add	eax, DWORD PTR _k$[ebp]
	adc	edx, DWORD PTR _k$[ebp+4]
	mov	DWORD PTR _val$[ebp], eax
	mov	DWORD PTR _val$[ebp+4], edx
$LN7@scanIntAnd:

; 258  : 		}
; 259  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 260  : 	}

	jmp	$LN2@scanIntAnd
$LN3@scanIntAnd:

; 261  : 	putback(c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_putback
	add	esp, 4

; 262  : 
; 263  : 	if (isFloat)

	cmp	DWORD PTR _isFloat$[ebp], 0
	je	$LN8@scanIntAnd

; 264  : 	{
; 265  : 
; 266  : 		if (count >= 19)
; 267  : 		{
; 268  : 			/*intf("[STACK ERROR] number has to many digits  (Line %d)\n", Line);
; 269  : 			exit(1);*/
; 270  : 		}
; 271  : 		INT_VAL divNum = (INT_VAL)pow(10, ((double)count - dotPos));

	cvtsi2sd xmm0, DWORD PTR _count$[ebp]
	cvtsi2sd xmm1, DWORD PTR _dotPos$[ebp]
	subsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2
	mov	DWORD PTR _divNum$3[ebp], eax
	mov	DWORD PTR _divNum$3[ebp+4], edx

; 272  : 		double floatVal = (double)val / (double)divNum;

	mov	edx, DWORD PTR _val$[ebp+4]
	mov	ecx, DWORD PTR _val$[ebp]
	call	__ltod3
	mov	edx, DWORD PTR _divNum$3[ebp+4]
	mov	ecx, DWORD PTR _divNum$3[ebp]
	movsd	QWORD PTR tv243[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv243[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _floatVal$2[ebp], xmm1

; 273  : 		struct NumericVal floatStruct = { 0, floatVal, TT_FLOAT };

	xorps	xmm0, xmm0
	movlpd	QWORD PTR _floatStruct$1[ebp], xmm0
	movsd	xmm0, QWORD PTR _floatVal$2[ebp]
	movsd	QWORD PTR _floatStruct$1[ebp+8], xmm0
	mov	DWORD PTR _floatStruct$1[ebp+16], 16	; 00000010H

; 274  : 		return floatStruct;

	mov	eax, DWORD PTR $T4[ebp]
	mov	ecx, DWORD PTR _floatStruct$1[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _floatStruct$1[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _floatStruct$1[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _floatStruct$1[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _floatStruct$1[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _floatStruct$1[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN1@scanIntAnd
$LN8@scanIntAnd:

; 275  : 	}
; 276  : 
; 277  : 	if (count >= 10 && firstNum > 1)
; 278  : 	{
; 279  : 		/*printf("[STACK ERROR] number has to many digits  (Line %d)\n", Line);
; 280  : 		exit(1)*/
; 281  : 	}
; 282  : 
; 283  : 
; 284  : 	struct NumericVal intStruct = { val, 0, TT_INT };

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR _intStruct$[ebp], eax
	mov	ecx, DWORD PTR _val$[ebp+4]
	mov	DWORD PTR _intStruct$[ebp+4], ecx
	xorps	xmm0, xmm0
	movsd	QWORD PTR _intStruct$[ebp+8], xmm0
	mov	DWORD PTR _intStruct$[ebp+16], 5

; 285  : 	return intStruct;

	mov	eax, DWORD PTR $T4[ebp]
	mov	ecx, DWORD PTR _intStruct$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _intStruct$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _intStruct$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _intStruct$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _intStruct$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _intStruct$[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T4[ebp]
$LN1@scanIntAnd:

; 286  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@scanIntAnd
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN16@scanIntAnd:
	DD	2
	DD	$LN15@scanIntAnd
$LN15@scanIntAnd:
	DD	-144					; ffffff70H
	DD	24					; 00000018H
	DD	$LN13@scanIntAnd
	DD	-176					; ffffff50H
	DD	24					; 00000018H
	DD	$LN14@scanIntAnd
$LN14@scanIntAnd:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN13@scanIntAnd:
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
_scanIntAndFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _chrpos
_TEXT	SEGMENT
tv69 = -208						; size = 4
_p$ = -8						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_chrpos	PROC						; COMDAT

; 227  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 228  : 	char* p;
; 229  : 
; 230  : 	p = strchr(s, c);

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 231  : 	return (p ? p - s : -1);

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $LN3@chrpos
	mov	eax, DWORD PTR _p$[ebp]
	sub	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@chrpos
$LN3@chrpos:
	mov	DWORD PTR tv69[ebp], -1
$LN4@chrpos:
	mov	eax, DWORD PTR tv69[ebp]

; 232  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_chrpos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_tokens
_TEXT	SEGMENT
_c$ = -8						; size = 4
_tokenList$ = 8						; size = 4
_t$ = 12						; size = 4
_scan_tokens PROC					; COMDAT

; 299  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 300  : 	int c = 0;

	mov	DWORD PTR _c$[ebp], 0
$LN2@scan_token:

; 301  : 
; 302  : 	while (c != EOF)

	cmp	DWORD PTR _c$[ebp], -1
	je	SHORT $LN1@scan_token

; 303  : 	{
; 304  : 		//scan_curToken(tokenList, t, c);
; 305  : 	}

	jmp	SHORT $LN2@scan_token
$LN1@scan_token:

; 306  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_scan_tokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _skip
_TEXT	SEGMENT
_c$ = -8						; size = 4
_skip	PROC						; COMDAT

; 214  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 215  : 	int c;
; 216  : 
; 217  : 	c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax
$LN2@skip:

; 218  : 	while (' ' == c || '\t' == c || '\n' == c || '\r' == c || '\f' == c)

	cmp	DWORD PTR _c$[ebp], 32			; 00000020H
	je	SHORT $LN4@skip
	cmp	DWORD PTR _c$[ebp], 9
	je	SHORT $LN4@skip
	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	je	SHORT $LN4@skip
	cmp	DWORD PTR _c$[ebp], 13			; 0000000dH
	je	SHORT $LN4@skip
	cmp	DWORD PTR _c$[ebp], 12			; 0000000cH
	jne	SHORT $LN3@skip
$LN4@skip:

; 219  : 	{
; 220  : 		c = next();

	call	_next
	mov	DWORD PTR _c$[ebp], eax

; 221  : 	}

	jmp	SHORT $LN2@skip
$LN3@skip:

; 222  : 	return c;

	mov	eax, DWORD PTR _c$[ebp]

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _putback
_TEXT	SEGMENT
_c$ = 8							; size = 4
_putback PROC						; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 210  : 	Putback = c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _Putback, eax

; 211  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_putback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _next
_TEXT	SEGMENT
_c$ = -8						; size = 4
_next	PROC						; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __56B56370_scan@c
	call	@__CheckForDebuggerJustMyCode@4

; 193  : 	int c;
; 194  : 
; 195  : 	if (Putback)

	cmp	DWORD PTR _Putback, 0
	je	SHORT $LN2@next

; 196  : 	{
; 197  : 		c = Putback;

	mov	eax, DWORD PTR _Putback
	mov	DWORD PTR _c$[ebp], eax

; 198  : 		Putback = 0;

	mov	DWORD PTR _Putback, 0

; 199  : 		return c;

	mov	eax, DWORD PTR _c$[ebp]
	jmp	SHORT $LN1@next
$LN2@next:

; 200  : 	}
; 201  : 
; 202  : 	c = fgetc(Infile);

	mov	esi, esp
	mov	eax, DWORD PTR _Infile
	push	eax
	call	DWORD PTR __imp__fgetc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _c$[ebp], eax

; 203  : 	if ('\n' == c)

	cmp	DWORD PTR _c$[ebp], 10			; 0000000aH
	jne	SHORT $LN3@next

; 204  : 		Line++;

	mov	eax, DWORD PTR _Line
	add	eax, 1
	mov	DWORD PTR _Line, eax
$LN3@next:

; 205  : 	return c;

	mov	eax, DWORD PTR _c$[ebp]
$LN1@next:

; 206  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_identToken
_TEXT	SEGMENT
_initToken$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_line$ = 12						; size = 4
_identToken_name$ = 16					; size = 4
_identToken_data$ = 20					; size = 8
_data$ = 28						; size = 4
_newToken_identToken PROC				; COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 232  : 	struct Token* initToken = malloc(sizeof(struct Token));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initToken$[ebp], eax

; 233  : 	initToken->tokenType = tokenType;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax], ecx

; 234  : 	initToken->intValue = 0;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 235  : 	initToken->line = line;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 236  : 	initToken->strVal = NULL;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	DWORD PTR [eax+20], 0

; 237  : 	initToken->floatVal = 0;

	mov	eax, DWORD PTR _initToken$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+24], xmm0

; 238  : 	initToken->IdentToken_name = identToken_name;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _identToken_name$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 239  : 	initToken->IdentToken_data = identToken_data;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _identToken_data$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	edx, DWORD PTR _identToken_data$[ebp+4]
	mov	DWORD PTR [eax+44], edx

; 240  : 	initToken->data = data;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 241  : 	return initToken;

	mov	eax, DWORD PTR _initToken$[ebp]

; 242  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_newToken_identToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_float
_TEXT	SEGMENT
_initToken_float$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_floatVal$ = 12						; size = 8
_line$ = 20						; size = 4
_data$ = 24						; size = 4
_newToken_float PROC					; COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 218  : 	struct Token* initToken_float = malloc(sizeof(struct Token));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initToken_float$[ebp], eax

; 219  : 	initToken_float->tokenType = tokenType;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax], ecx

; 220  : 	initToken_float->intValue = 0;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0

; 221  : 	initToken_float->line = line;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 222  : 	initToken_float->strVal = NULL;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	DWORD PTR [eax+20], 0

; 223  : 	initToken_float->floatVal = floatVal;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	movsd	xmm0, QWORD PTR _floatVal$[ebp]
	movsd	QWORD PTR [eax+24], xmm0

; 224  : 	initToken_float->IdentToken_name = NULL;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	DWORD PTR [eax+32], 0

; 225  : 	initToken_float->IdentToken_data = 0;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 226  : 	initToken_float->data = data;

	mov	eax, DWORD PTR _initToken_float$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 227  : 	return initToken_float;

	mov	eax, DWORD PTR _initToken_float$[ebp]

; 228  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_newToken_float ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_str
_TEXT	SEGMENT
_initToken_str$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_intValue$ = 12						; size = 8
_line$ = 20						; size = 4
_strVal$ = 24						; size = 4
_data$ = 28						; size = 4
_newToken_str PROC					; COMDAT

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 204  : 	struct Token* initToken_str = malloc(sizeof(struct Token));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initToken_str$[ebp], eax

; 205  : 	initToken_str->tokenType = tokenType;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax], ecx

; 206  : 	initToken_str->intValue = intValue;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	ecx, DWORD PTR _intValue$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _intValue$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 207  : 	initToken_str->line = line;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 208  : 	initToken_str->strVal = strVal;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	ecx, DWORD PTR _strVal$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 209  : 	initToken_str->floatVal = 0;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+24], xmm0

; 210  : 	initToken_str->IdentToken_name = NULL;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	DWORD PTR [eax+32], 0

; 211  : 	initToken_str->IdentToken_data = 0;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 212  : 	initToken_str->data = data;

	mov	eax, DWORD PTR _initToken_str$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 213  : 	return initToken_str;

	mov	eax, DWORD PTR _initToken_str$[ebp]

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_newToken_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken
_TEXT	SEGMENT
_initToken$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_intValue$ = 12						; size = 8
_line$ = 20						; size = 4
_data$ = 24						; size = 4
_newToken PROC						; COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 190  : 	struct Token* initToken = malloc(sizeof(struct Token));

	mov	esi, esp
	push	56					; 00000038H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initToken$[ebp], eax

; 191  : 	initToken->tokenType = tokenType;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax], ecx

; 192  : 	initToken->intValue = intValue;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _intValue$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _intValue$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 193  : 	initToken->line = line;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 194  : 	initToken->strVal = NULL;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	DWORD PTR [eax+20], 0

; 195  : 	initToken->floatVal = 0;

	mov	eax, DWORD PTR _initToken$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+24], xmm0

; 196  : 	initToken->IdentToken_name = NULL;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	DWORD PTR [eax+32], 0

; 197  : 	initToken->IdentToken_data = 0;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	DWORD PTR [eax+40], 0
	mov	DWORD PTR [eax+44], 0

; 198  : 	initToken->data = data;

	mov	eax, DWORD PTR _initToken$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 199  : 	return initToken;

	mov	eax, DWORD PTR _initToken$[ebp]

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_newToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _new_DATA_STRUCT
_TEXT	SEGMENT
_init$ = -8						; size = 4
_strVal$ = 8						; size = 4
_boolVal$ = 12						; size = 4
_doubleVal$ = 16					; size = 4
_intVal$ = 20						; size = 8
_charVal$ = 28						; size = 4
_dataType$ = 32						; size = 4
_minusVal$ = 36						; size = 4
_new_DATA_STRUCT PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 29   : 	struct DATA_STRUCT* init = malloc(sizeof(struct DATA_STRUCT));

	mov	esi, esp
	push	28					; 0000001cH
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _init$[ebp], eax

; 30   : 	init->strVal = strVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _strVal$[ebp]
	mov	DWORD PTR [eax], ecx

; 31   : 	init->boolVal = boolVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _boolVal$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 32   : 	init->doubleVal = doubleVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _doubleVal$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 33   : 	init->intVal = intVal;

	mov	eax, DWORD PTR _intVal$[ebp]
	mov	ecx, DWORD PTR _init$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 34   : 	init->charVal = charVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _charVal$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 35   : 	init->dataType = dataType;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _dataType$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 36   : 	init->minusVal = minusVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _minusVal$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 37   : 	return init;

	mov	eax, DWORD PTR _init$[ebp]

; 38   : };

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_new_DATA_STRUCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
