; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_globl_open_curly_count
PUBLIC	_globl_closed_curly_count
PUBLIC	_globl_current_depth
PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_05OODBEKIG@while@				; `string'
PUBLIC	??_C@_03MEPDGFMA@var@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
_BSS	SEGMENT
_globl_open_curly_count DD 01H DUP (?)
_globl_closed_curly_count DD 01H DUP (?)
_globl_current_depth DD 01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8478A1A4_tokens@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__B5AFADD0_genAST@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var@
CONST	SEGMENT
??_C@_03MEPDGFMA@var@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while@
CONST	SEGMENT
??_C@_05OODBEKIG@while@ DB 'while', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_mkastnode
PUBLIC	_mkastnode_const
PUBLIC	_mkastnode_left
PUBLIC	_mkastnode_ident
PUBLIC	_binexpr
PUBLIC	_binexpr_int
PUBLIC	_genMainAST
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@ ; `string'
PUBLIC	??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@ ; `string'
PUBLIC	??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ ; `string'
PUBLIC	??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@ ; `string'
PUBLIC	??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ ; `string'
PUBLIC	??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@ ; `string'
PUBLIC	??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@ ; `string'
PUBLIC	??_C@_0DF@NLEHDODD@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ ; `string'
PUBLIC	??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@ ; `string'
PUBLIC	??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@ ; `string'
PUBLIC	??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@ ; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_newID_token:PROC
EXTRN	_genVarAST:PROC
EXTRN	_genIdentAST:PROC
EXTRN	_scan_curToken:PROC
EXTRN	_putBack_curToken:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	_Line:DWORD
EXTRN	_currentToken:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_leftParenCount DD 01H DUP (?)
_rightParenCount DD 01H DUP (?)
_globl_inParen DD 01H DUP (?)
_globl_parenDelta DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@
CONST	SEGMENT
??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@ DB '[SYNTAX'
	DB	' ERROR] expected an identifier (Line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@
CONST	SEGMENT
??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@ DB '['
	DB	'SYNTAX ERROR] expected an '';'' in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
CONST	SEGMENT
??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@ DB '['
	DB	'SYNTAX ERROR] ''('' is missing in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NLEHDODD@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
CONST	SEGMENT
??_C@_0DF@NLEHDODD@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ DB '[SYNTAX'
	DB	' ERROR] expected a binary operator (Line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@
CONST	SEGMENT
??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@ DB '['
	DB	'SYNTAX ERROR] cannot use '';'' inside an expression (Line %d)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
CONST	SEGMENT
??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@ DB '['
	DB	'SYNTAX ERROR] expected a '';'' in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
CONST	SEGMENT
??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ DB '[SYNTAX'
	DB	' ERROR] expected a binary operator or '';'' (Line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@
CONST	SEGMENT
??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@ DB '[SYNTAX'
	DB	' ERROR] expected a number (Line %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
CONST	SEGMENT
??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ DB '[SYNTAX'
	DB	' ERROR] expected a binary operator in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@
CONST	SEGMENT
??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@ DB '[SYNATX'
	DB	' ERROR] expected a number (Line %d) (Token %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
CONST	SEGMENT
??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@ DB '[SYNTAX '
	DB	'ERROR] unclosed parentheses in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@ DB '[SYNTAX ERRO'
	DB	'R] Line %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_binOperators DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	06H
	DD	011H
	DD	04H
	DD	016H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	017H
	DD	018H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _getOpPrecedence
_TEXT	SEGMENT
tv65 = -208						; size = 4
_tt$ = -8						; size = 4
_t$ = 8							; size = 4
_getOpPrecedence PROC					; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  : 	int tt = t->tokenType;

  00028	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d f8	 mov	 DWORD PTR _tt$[ebp], ecx

; 130  : 
; 131  : 	switch (tt)

  00030	8b 45 f8	 mov	 eax, DWORD PTR _tt$[ebp]
  00033	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  00039	83 bd 30 ff ff
	ff 1e		 cmp	 DWORD PTR tv65[ebp], 30	; 0000001eH
  00040	77 7b		 ja	 SHORT $LN2@getOpPrece
  00042	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  00048	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN21@getOpPrece[ecx]
  0004f	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN22@getOpPrece[edx*4]
$LN4@getOpPrece:

; 132  : 	{
; 133  : 	case TT_INT:             return 0;

  00056	33 c0		 xor	 eax, eax
  00058	eb 66		 jmp	 SHORT $LN1@getOpPrece
$LN5@getOpPrece:

; 134  : 	case TT_FLOAT:           return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 62		 jmp	 SHORT $LN1@getOpPrece
$LN6@getOpPrece:

; 135  : 	case TT_PLUS:            return 10;

  0005e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00063	eb 5b		 jmp	 SHORT $LN1@getOpPrece
$LN7@getOpPrece:

; 136  : 	case TT_MINUS:           return 10;

  00065	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0006a	eb 54		 jmp	 SHORT $LN1@getOpPrece
$LN8@getOpPrece:

; 137  : 	case TT_MUL:	         return 20;

  0006c	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00071	eb 4d		 jmp	 SHORT $LN1@getOpPrece
$LN9@getOpPrece:

; 138  : 	case TT_DIV:	         return 20;

  00073	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  00078	eb 46		 jmp	 SHORT $LN1@getOpPrece
$LN10@getOpPrece:

; 139  : 	case TT_OP_END:		     return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	eb 42		 jmp	 SHORT $LN1@getOpPrece
$LN11@getOpPrece:

; 140  : 	case TT_POW:	         return 25;

  0007e	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  00083	eb 3b		 jmp	 SHORT $LN1@getOpPrece
$LN12@getOpPrece:

; 141  : 	case TT_EQUALS_CMP:	     return 5;

  00085	b8 05 00 00 00	 mov	 eax, 5
  0008a	eb 34		 jmp	 SHORT $LN1@getOpPrece
$LN13@getOpPrece:

; 142  : 	case TT_NOT_EQUALS:      return 5;

  0008c	b8 05 00 00 00	 mov	 eax, 5
  00091	eb 2d		 jmp	 SHORT $LN1@getOpPrece
$LN14@getOpPrece:

; 143  : 	case TT_GREATER:	     return 5;

  00093	b8 05 00 00 00	 mov	 eax, 5
  00098	eb 26		 jmp	 SHORT $LN1@getOpPrece
$LN15@getOpPrece:

; 144  : 	case TT_SMALLER:	     return 5;

  0009a	b8 05 00 00 00	 mov	 eax, 5
  0009f	eb 1f		 jmp	 SHORT $LN1@getOpPrece
$LN16@getOpPrece:

; 145  : 	case TT_GREATER_EQUALS:	 return 5;

  000a1	b8 05 00 00 00	 mov	 eax, 5
  000a6	eb 18		 jmp	 SHORT $LN1@getOpPrece
$LN17@getOpPrece:

; 146  : 	case TT_SMALLER_EQUALS:  return 5;

  000a8	b8 05 00 00 00	 mov	 eax, 5
  000ad	eb 11		 jmp	 SHORT $LN1@getOpPrece
$LN18@getOpPrece:

; 147  : 	case TT_AND:             return 2;

  000af	b8 02 00 00 00	 mov	 eax, 2
  000b4	eb 0a		 jmp	 SHORT $LN1@getOpPrece
$LN19@getOpPrece:

; 148  : 	case TT_OR:              return 2;

  000b6	b8 02 00 00 00	 mov	 eax, 2
  000bb	eb 03		 jmp	 SHORT $LN1@getOpPrece
$LN2@getOpPrece:

; 149  : 	}
; 150  : 	return -1;

  000bd	83 c8 ff	 or	 eax, -1
$LN1@getOpPrece:

; 151  : }

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  000c9	3b ec		 cmp	 ebp, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
$LN22@getOpPrece:
  000d4	00 00 00 00	 DD	 $LN6@getOpPrece
  000d8	00 00 00 00	 DD	 $LN7@getOpPrece
  000dc	00 00 00 00	 DD	 $LN8@getOpPrece
  000e0	00 00 00 00	 DD	 $LN9@getOpPrece
  000e4	00 00 00 00	 DD	 $LN11@getOpPrece
  000e8	00 00 00 00	 DD	 $LN4@getOpPrece
  000ec	00 00 00 00	 DD	 $LN10@getOpPrece
  000f0	00 00 00 00	 DD	 $LN5@getOpPrece
  000f4	00 00 00 00	 DD	 $LN12@getOpPrece
  000f8	00 00 00 00	 DD	 $LN18@getOpPrece
  000fc	00 00 00 00	 DD	 $LN19@getOpPrece
  00100	00 00 00 00	 DD	 $LN13@getOpPrece
  00104	00 00 00 00	 DD	 $LN14@getOpPrece
  00108	00 00 00 00	 DD	 $LN15@getOpPrece
  0010c	00 00 00 00	 DD	 $LN16@getOpPrece
  00110	00 00 00 00	 DD	 $LN17@getOpPrece
  00114	00 00 00 00	 DD	 $LN2@getOpPrece
$LN21@getOpPrece:
  00118	00		 DB	 0
  00119	01		 DB	 1
  0011a	02		 DB	 2
  0011b	03		 DB	 3
  0011c	04		 DB	 4
  0011d	05		 DB	 5
  0011e	06		 DB	 6
  0011f	10		 DB	 16			; 00000010H
  00120	10		 DB	 16			; 00000010H
  00121	10		 DB	 16			; 00000010H
  00122	10		 DB	 16			; 00000010H
  00123	10		 DB	 16			; 00000010H
  00124	10		 DB	 16			; 00000010H
  00125	10		 DB	 16			; 00000010H
  00126	10		 DB	 16			; 00000010H
  00127	10		 DB	 16			; 00000010H
  00128	07		 DB	 7
  00129	10		 DB	 16			; 00000010H
  0012a	10		 DB	 16			; 00000010H
  0012b	10		 DB	 16			; 00000010H
  0012c	10		 DB	 16			; 00000010H
  0012d	10		 DB	 16			; 00000010H
  0012e	08		 DB	 8
  0012f	09		 DB	 9
  00130	0a		 DB	 10			; 0000000aH
  00131	10		 DB	 16			; 00000010H
  00132	0b		 DB	 11			; 0000000bH
  00133	0c		 DB	 12			; 0000000cH
  00134	0d		 DB	 13			; 0000000dH
  00135	0e		 DB	 14			; 0000000eH
  00136	0f		 DB	 15			; 0000000fH
_getOpPrecedence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _rightParenCode
_TEXT	SEGMENT
_interrupt_token$ = 8					; size = 4
_rightParenCode PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@rightParen:

; 60   : 	while (currentToken->tokenType == TT_RIGHT_PAREN)

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0002d	83 38 0a	 cmp	 DWORD PTR [eax], 10	; 0000000aH
  00030	75 6f		 jne	 SHORT $LN3@rightParen

; 61   : 	{
; 62   : 		if (interrupt_token != -1)

  00032	83 7d 08 ff	 cmp	 DWORD PTR _interrupt_token$[ebp], -1
  00036	74 55		 je	 SHORT $LN4@rightParen

; 63   : 		{
; 64   : 			if (currentToken->tokenType == TT_RIGHT_PAREN)

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0003d	83 38 0a	 cmp	 DWORD PTR [eax], 10	; 0000000aH
  00040	75 4b		 jne	 SHORT $LN4@rightParen

; 65   : 			{
; 66   : 				scan_curToken();

  00042	e8 00 00 00 00	 call	 _scan_curToken

; 67   : 				if (currentToken->tokenType == interrupt_token)

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	3b 4d 08	 cmp	 ecx, DWORD PTR _interrupt_token$[ebp]
  00051	75 2c		 jne	 SHORT $LN6@rightParen

; 68   : 				{
; 69   : 					rightParenCount = 0;

  00053	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _rightParenCount, 0

; 70   : 					leftParenCount = 0;

  0005d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _leftParenCount, 0

; 71   : 					putBack_curToken(currentToken);

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _putBack_curToken
  00072	83 c4 04	 add	 esp, 4

; 72   : 					return 1;

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	e9 f3 00 00 00	 jmp	 $LN12@rightParen
$LN6@rightParen:

; 73   : 				}
; 74   : 				putBack_curToken(currentToken);

  0007f	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 _putBack_curToken
  0008a	83 c4 04	 add	 esp, 4
$LN4@rightParen:

; 75   : 			}
; 76   : 		}
; 77   : 		rightParenCount++;

  0008d	a1 00 00 00 00	 mov	 eax, DWORD PTR _rightParenCount
  00092	83 c0 01	 add	 eax, 1
  00095	a3 00 00 00 00	 mov	 DWORD PTR _rightParenCount, eax

; 78   : 		scan_curToken();

  0009a	e8 00 00 00 00	 call	 _scan_curToken

; 79   : 	}

  0009f	eb 87		 jmp	 SHORT $LN2@rightParen
$LN3@rightParen:

; 80   : 
; 81   : 	if (leftParenCount != rightParenCount)

  000a1	a1 00 00 00 00	 mov	 eax, DWORD PTR _leftParenCount
  000a6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rightParenCount
  000ac	74 1a		 je	 SHORT $LN7@rightParen

; 82   : 	{
; 83   : 		globl_inParen = PAREN_PRECEDENCE;

  000ae	c7 05 00 00 00
	00 14 00 00 00	 mov	 DWORD PTR _globl_inParen, 20 ; 00000014H

; 84   : 		globl_parenDelta = leftParenCount - rightParenCount;

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _leftParenCount
  000bd	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _rightParenCount
  000c3	a3 00 00 00 00	 mov	 DWORD PTR _globl_parenDelta, eax
$LN7@rightParen:

; 85   : 	}
; 86   : 
; 87   : 	if (leftParenCount == rightParenCount)

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _leftParenCount
  000cd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rightParenCount
  000d3	75 28		 jne	 SHORT $LN8@rightParen

; 88   : 	{
; 89   : 		globl_inParen = 0;

  000d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _globl_inParen, 0

; 90   : 		leftParenCount = 0;

  000df	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _leftParenCount, 0

; 91   : 		rightParenCount = 0;

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _rightParenCount, 0

; 92   : 		globl_parenDelta = 0;

  000f3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _globl_parenDelta, 0
$LN8@rightParen:

; 93   : 	}
; 94   : 
; 95   : 	if (currentToken->tokenType == TT_OP_END && leftParenCount != rightParenCount)

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00102	83 38 06	 cmp	 DWORD PTR [eax], 6
  00105	75 31		 jne	 SHORT $LN9@rightParen
  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR _leftParenCount
  0010c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _rightParenCount
  00112	74 24		 je	 SHORT $LN9@rightParen

; 96   : 	{
; 97   : 		printf("[SYNTAX ERROR] unclosed parentheses in Line %d\n", Line);

  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00119	50		 push	 eax
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
  0011f	e8 00 00 00 00	 call	 _printf
  00124	83 c4 08	 add	 esp, 8

; 98   : 		exit(1);

  00127	8b f4		 mov	 esi, esp
  00129	6a 01		 push	 1
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00131	3b f4		 cmp	 esi, esp
  00133	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@rightParen:

; 99   : 	}
; 100  : 	if (currentToken->tokenType == TT_INT || currentToken->tokenType == TT_FLOAT)

  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0013d	83 38 05	 cmp	 DWORD PTR [eax], 5
  00140	74 0a		 je	 SHORT $LN11@rightParen
  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00147	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  0014a	75 24		 jne	 SHORT $LN10@rightParen
$LN11@rightParen:

; 101  : 	{
; 102  : 		printf("[SYNTAX ERROR] expected a binary operator in Line %d\n", Line);

  0014c	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
  00157	e8 00 00 00 00	 call	 _printf
  0015c	83 c4 08	 add	 esp, 8

; 103  : 		exit(1);

  0015f	8b f4		 mov	 esi, esp
  00161	6a 01		 push	 1
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00169	3b f4		 cmp	 esi, esp
  0016b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@rightParen:

; 104  : 	}
; 105  : 	return 0;

  00170	33 c0		 xor	 eax, eax
$LN12@rightParen:

; 106  : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0017b	3b ec		 cmp	 ebp, esp
  0017d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00182	8b e5		 mov	 esp, ebp
  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_rightParenCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _tokenIsBinOp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_t$ = 8							; size = 4
_tokenIsBinOp PROC					; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 155  : 	for (size_t i = 0; i < arraySize(binOperators); i++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@tokenIsBin
$LN2@tokenIsBin:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@tokenIsBin:
  0003a	83 7d f8 0f	 cmp	 DWORD PTR _i$1[ebp], 15	; 0000000fH
  0003e	73 1a		 jae	 SHORT $LN3@tokenIsBin

; 156  : 	{
; 157  : 		if (t->tokenType == binOperators[i])

  00040	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  00046	8b 10		 mov	 edx, DWORD PTR [eax]
  00048	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _binOperators[ecx*4]
  0004f	75 07		 jne	 SHORT $LN5@tokenIsBin

; 158  : 		{
; 159  : 			return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	eb 04		 jmp	 SHORT $LN1@tokenIsBin
$LN5@tokenIsBin:

; 160  : 		}
; 161  : 	}

  00058	eb d7		 jmp	 SHORT $LN2@tokenIsBin
$LN3@tokenIsBin:

; 162  : 	return 0;

  0005a	33 c0		 xor	 eax, eax
$LN1@tokenIsBin:

; 163  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_tokenIsBinOp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _leftParenCode
_TEXT	SEGMENT
_minusToken$ = 8					; size = 4
_leftParenCode PROC					; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@leftParenC:

; 35   : 	while (currentToken->tokenType == TT_LEFT_PAREN)

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0002d	83 38 09	 cmp	 DWORD PTR [eax], 9
  00030	0f 85 ba 00 00
	00		 jne	 $LN8@leftParenC

; 36   : 	{
; 37   : 		leftParenCount++;

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR _leftParenCount
  0003b	83 c0 01	 add	 eax, 1
  0003e	a3 00 00 00 00	 mov	 DWORD PTR _leftParenCount, eax

; 38   : 		if (minusToken->tokenType == TT_MINUS)

  00043	8b 45 08	 mov	 eax, DWORD PTR _minusToken$[ebp]
  00046	83 38 01	 cmp	 DWORD PTR [eax], 1
  00049	75 24		 jne	 SHORT $LN4@leftParenC

; 39   : 		{
; 40   : 			printf("[SYNTAX ERROR] Line %d\n", Line);

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@
  00056	e8 00 00 00 00	 call	 _printf
  0005b	83 c4 08	 add	 esp, 8

; 41   : 			exit(1);

  0005e	8b f4		 mov	 esi, esp
  00060	6a 01		 push	 1
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN4@leftParenC:

; 42   : 		}
; 43   : 		scan_curToken();

  0006f	e8 00 00 00 00	 call	 _scan_curToken

; 44   : 		if (currentToken->tokenType == TT_EOF || currentToken->tokenType == TT_OP_END)

  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00079	83 38 11	 cmp	 DWORD PTR [eax], 17	; 00000011H
  0007c	74 0a		 je	 SHORT $LN6@leftParenC
  0007e	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00083	83 38 06	 cmp	 DWORD PTR [eax], 6
  00086	75 24		 jne	 SHORT $LN5@leftParenC
$LN6@leftParenC:

; 45   : 		{
; 46   : 			printf("[SYNTAX ERROR] unclosed parentheses in Line %d\n", Line);

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
  00093	e8 00 00 00 00	 call	 _printf
  00098	83 c4 08	 add	 esp, 8

; 47   : 			exit(1);

  0009b	8b f4		 mov	 esi, esp
  0009d	6a 01		 push	 1
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@leftParenC:

; 48   : 		}
; 49   : 		if (tokenIsBinOp(currentToken))

  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _tokenIsBinOp
  000b7	83 c4 04	 add	 esp, 4
  000ba	85 c0		 test	 eax, eax
  000bc	74 2d		 je	 SHORT $LN7@leftParenC

; 50   : 		{
; 51   : 			printf("[SYNATX ERROR] expected a number (Line %d) (Token %d)\n", Line, currentToken->tokenType);

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	51		 push	 ecx
  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Line
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@
  000d2	e8 00 00 00 00	 call	 _printf
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 52   : 			exit(1);

  000da	8b f4		 mov	 esi, esp
  000dc	6a 01		 push	 1
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000e4	3b f4		 cmp	 esi, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@leftParenC:

; 53   : 		}
; 54   : 	}

  000eb	e9 38 ff ff ff	 jmp	 $LN2@leftParenC
$LN8@leftParenC:

; 55   : }

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx
  000f3	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_leftParenCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _genMainAST
_TEXT	SEGMENT
tv65 = -256						; size = 4
_varName_save$1 = -56					; size = 4
_t$ = -44						; size = 4
_node$ = -32						; size = 4
_right$ = -20						; size = 4
_left$ = -8						; size = 4
_scope_depth$ = 8					; size = 4
_genMainAST PROC					; COMDAT

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 00 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-256]
  00012	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 355  : 	struct AST_Node* left = NULL, * right = NULL, * node = NULL;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _left$[ebp], 0
  0002f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _right$[ebp], 0
  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _node$[ebp], 0

; 356  : 	scan_curToken();

  0003d	e8 00 00 00 00	 call	 _scan_curToken

; 357  : 
; 358  : 
; 359  : 	struct Token* t = currentToken;

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00047	89 45 d4	 mov	 DWORD PTR _t$[ebp], eax

; 360  : 
; 361  : 	switch (currentToken->tokenType)

  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  0005d	83 ea 07	 sub	 edx, 7
  00060	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  00066	83 bd 00 ff ff
	ff 0e		 cmp	 DWORD PTR tv65[ebp], 14	; 0000000eH
  0006d	0f 87 ca 03 00
	00		 ja	 $LN2@genMainAST
  00073	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00079	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN21@genMainAST[eax]
  00080	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN22@genMainAST[ecx*4]
$LN4@genMainAST:

; 362  : 	{
; 363  : 	case TT_PRINT:
; 364  : 
; 365  : 		scan_curToken();

  00087	e8 00 00 00 00	 call	 _scan_curToken

; 366  : 		if (currentToken->tokenType != TT_LEFT_PAREN)

  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00091	83 38 09	 cmp	 DWORD PTR [eax], 9
  00094	74 24		 je	 SHORT $LN5@genMainAST

; 367  : 		{
; 368  : 			printf("[SYNTAX ERROR] '(' is missing in Line %d\n", Line);

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0009b	50		 push	 eax
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
  000a1	e8 00 00 00 00	 call	 _printf
  000a6	83 c4 08	 add	 esp, 8

; 369  : 			exit(1);

  000a9	8b f4		 mov	 esi, esp
  000ab	6a 01		 push	 1
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000b3	3b f4		 cmp	 esi, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@genMainAST:

; 370  : 		}
; 371  : 		left = binexpr_int(BINEXPR_PTP_STARTVAL, TT_OP_END);

  000ba	6a 06		 push	 6
  000bc	6a 00		 push	 0
  000be	e8 00 00 00 00	 call	 _binexpr_int
  000c3	83 c4 08	 add	 esp, 8
  000c6	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 372  : 		node = mkastnode(t->tokenType, t->intValue, t->floatVal, left, NULL, NULL, NULL);

  000c9	6a 00		 push	 0
  000cb	6a 00		 push	 0
  000cd	6a 00		 push	 0
  000cf	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d d4	 mov	 ecx, DWORD PTR _t$[ebp]
  000d6	83 ec 08	 sub	 esp, 8
  000d9	f2 0f 10 41 18	 movsd	 xmm0, QWORD PTR [ecx+24]
  000de	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e3	8b 55 d4	 mov	 edx, DWORD PTR _t$[ebp]
  000e6	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000e9	50		 push	 eax
  000ea	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000ed	51		 push	 ecx
  000ee	8b 55 d4	 mov	 edx, DWORD PTR _t$[ebp]
  000f1	8b 02		 mov	 eax, DWORD PTR [edx]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _mkastnode
  000f9	83 c4 24	 add	 esp, 36			; 00000024H
  000fc	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 373  : 		scan_curToken();

  000ff	e8 00 00 00 00	 call	 _scan_curToken

; 374  : 		if (currentToken->tokenType != TT_OP_END)

  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00109	83 38 06	 cmp	 DWORD PTR [eax], 6
  0010c	74 24		 je	 SHORT $LN6@genMainAST

; 375  : 		{
; 376  : 			printf("[SYNTAX ERROR] expected an ';' in Line %d\n", Line);

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00113	50		 push	 eax
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@
  00119	e8 00 00 00 00	 call	 _printf
  0011e	83 c4 08	 add	 esp, 8

; 377  : 			exit(1);

  00121	8b f4		 mov	 esi, esp
  00123	6a 01		 push	 1
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0012b	3b f4		 cmp	 esi, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@genMainAST:

; 378  : 		}
; 379  : 		break;

  00132	e9 06 03 00 00	 jmp	 $LN2@genMainAST
$LN7@genMainAST:

; 380  : 
; 381  : 	case TT_VAR:
; 382  : 		node = genVarAST();

  00137	e8 00 00 00 00	 call	 _genVarAST
  0013c	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 383  : 		node->right = genMainAST(scope_depth);

  0013f	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _genMainAST
  00148	83 c4 04	 add	 esp, 4
  0014b	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  0014e	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 384  : 		return node;

  00151	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  00154	e9 41 03 00 00	 jmp	 $LN1@genMainAST
$LN8@genMainAST:

; 385  : 
; 386  : 	case TT_IDENT:
; 387  : 		node = genIdentAST();

  00159	e8 00 00 00 00	 call	 _genIdentAST
  0015e	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 388  : 		node->right = genMainAST(scope_depth);

  00161	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _genMainAST
  0016a	83 c4 04	 add	 esp, 4
  0016d	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  00170	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 389  : 		return node;

  00173	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  00176	e9 1f 03 00 00	 jmp	 $LN1@genMainAST
$LN9@genMainAST:

; 390  : 
; 391  : 	case TT_UNDEF:
; 392  : 		scan_curToken();

  0017b	e8 00 00 00 00	 call	 _scan_curToken

; 393  : 		if (currentToken->tokenType != TT_IDENT)

  00180	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00185	83 38 12	 cmp	 DWORD PTR [eax], 18	; 00000012H
  00188	74 24		 je	 SHORT $LN10@genMainAST

; 394  : 		{
; 395  : 			printf("[SYNTAX ERROR] expected an identifier (Line %d)\n", Line);

  0018a	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0018f	50		 push	 eax
  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@
  00195	e8 00 00 00 00	 call	 _printf
  0019a	83 c4 08	 add	 esp, 8

; 396  : 			exit(1);

  0019d	8b f4		 mov	 esi, esp
  0019f	6a 01		 push	 1
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  001a7	3b f4		 cmp	 esi, esp
  001a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN10@genMainAST:

; 397  : 		}
; 398  : 		char* varName_save = calloc(strlen(currentToken->IdentToken_name), sizeof(char));

  001ae	8b f4		 mov	 esi, esp
  001b0	6a 01		 push	 1
  001b2	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  001b7	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001ba	51		 push	 ecx
  001bb	e8 00 00 00 00	 call	 _strlen
  001c0	83 c4 04	 add	 esp, 4
  001c3	50		 push	 eax
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  001ca	83 c4 08	 add	 esp, 8
  001cd	3b f4		 cmp	 esi, esp
  001cf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d4	89 45 c8	 mov	 DWORD PTR _varName_save$1[ebp], eax

; 399  : 		varName_save = strcpy(varName_save, currentToken->IdentToken_name);

  001d7	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  001dc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001df	51		 push	 ecx
  001e0	8b 55 c8	 mov	 edx, DWORD PTR _varName_save$1[ebp]
  001e3	52		 push	 edx
  001e4	e8 00 00 00 00	 call	 _strcpy
  001e9	83 c4 08	 add	 esp, 8
  001ec	89 45 c8	 mov	 DWORD PTR _varName_save$1[ebp], eax

; 400  : 		left = mkastnode_ident(TT_IDENT, currentToken->intValue, currentToken->floatVal, NULL, NULL, NULL, varName_save, NULL);

  001ef	6a 00		 push	 0
  001f1	8b 45 c8	 mov	 eax, DWORD PTR _varName_save$1[ebp]
  001f4	50		 push	 eax
  001f5	6a 00		 push	 0
  001f7	6a 00		 push	 0
  001f9	6a 00		 push	 0
  001fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  00201	83 ec 08	 sub	 esp, 8
  00204	f2 0f 10 41 18	 movsd	 xmm0, QWORD PTR [ecx+24]
  00209	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _currentToken
  00214	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00217	50		 push	 eax
  00218	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0021b	51		 push	 ecx
  0021c	6a 12		 push	 18			; 00000012H
  0021e	e8 00 00 00 00	 call	 _mkastnode_ident
  00223	83 c4 28	 add	 esp, 40			; 00000028H
  00226	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 401  : 		scan_curToken();

  00229	e8 00 00 00 00	 call	 _scan_curToken

; 402  : 		if (currentToken->tokenType != TT_OP_END)

  0022e	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00233	83 38 06	 cmp	 DWORD PTR [eax], 6
  00236	74 24		 je	 SHORT $LN11@genMainAST

; 403  : 		{
; 404  : 			printf("[SYNTAX ERROR] expected a ';' in Line %d\n", Line);

  00238	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0023d	50		 push	 eax
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
  00243	e8 00 00 00 00	 call	 _printf
  00248	83 c4 08	 add	 esp, 8

; 405  : 			exit(1);

  0024b	8b f4		 mov	 esi, esp
  0024d	6a 01		 push	 1
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00255	3b f4		 cmp	 esi, esp
  00257	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN11@genMainAST:

; 406  : 		}
; 407  : 		right = genMainAST(scope_depth);

  0025c	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  0025f	50		 push	 eax
  00260	e8 00 00 00 00	 call	 _genMainAST
  00265	83 c4 04	 add	 esp, 4
  00268	89 45 ec	 mov	 DWORD PTR _right$[ebp], eax

; 408  : 		node = mkastnode(TT_UNDEF, 0, 0, left, right, NULL, NULL);

  0026b	6a 00		 push	 0
  0026d	6a 00		 push	 0
  0026f	8b 45 ec	 mov	 eax, DWORD PTR _right$[ebp]
  00272	50		 push	 eax
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _left$[ebp]
  00276	51		 push	 ecx
  00277	83 ec 08	 sub	 esp, 8
  0027a	0f 57 c0	 xorps	 xmm0, xmm0
  0027d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00282	6a 00		 push	 0
  00284	6a 00		 push	 0
  00286	6a 15		 push	 21			; 00000015H
  00288	e8 00 00 00 00	 call	 _mkastnode
  0028d	83 c4 24	 add	 esp, 36			; 00000024H
  00290	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 409  : 		return node;

  00293	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  00296	e9 ff 01 00 00	 jmp	 $LN1@genMainAST
$LN12@genMainAST:

; 410  : 
; 411  : 
; 412  : 	case TT_IF:
; 413  : 		scan_curToken();

  0029b	e8 00 00 00 00	 call	 _scan_curToken

; 414  : 		if (currentToken->tokenType != TT_LEFT_PAREN)

  002a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  002a5	83 38 09	 cmp	 DWORD PTR [eax], 9
  002a8	74 24		 je	 SHORT $LN13@genMainAST

; 415  : 		{
; 416  : 			printf("[SYNTAX ERROR] '(' is missing in Line %d\n", Line);

  002aa	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  002af	50		 push	 eax
  002b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
  002b5	e8 00 00 00 00	 call	 _printf
  002ba	83 c4 08	 add	 esp, 8

; 417  : 			exit(1);

  002bd	8b f4		 mov	 esi, esp
  002bf	6a 01		 push	 1
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  002c7	3b f4		 cmp	 esi, esp
  002c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@genMainAST:

; 418  : 		}
; 419  : 		node = mkastnode(TT_IF, 0, 0, NULL, NULL, NULL, NULL);

  002ce	6a 00		 push	 0
  002d0	6a 00		 push	 0
  002d2	6a 00		 push	 0
  002d4	6a 00		 push	 0
  002d6	83 ec 08	 sub	 esp, 8
  002d9	0f 57 c0	 xorps	 xmm0, xmm0
  002dc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002e1	6a 00		 push	 0
  002e3	6a 00		 push	 0
  002e5	6a 08		 push	 8
  002e7	e8 00 00 00 00	 call	 _mkastnode
  002ec	83 c4 24	 add	 esp, 36			; 00000024H
  002ef	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 420  : 		node->left = mkastnode(TT_ANY_OP, 0, 0, NULL, NULL, NULL, NULL);

  002f2	6a 00		 push	 0
  002f4	6a 00		 push	 0
  002f6	6a 00		 push	 0
  002f8	6a 00		 push	 0
  002fa	83 ec 08	 sub	 esp, 8
  002fd	0f 57 c0	 xorps	 xmm0, xmm0
  00300	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00305	6a 00		 push	 0
  00307	6a 00		 push	 0
  00309	6a 19		 push	 25			; 00000019H
  0030b	e8 00 00 00 00	 call	 _mkastnode
  00310	83 c4 24	 add	 esp, 36			; 00000024H
  00313	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  00316	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 421  : 		node->left->left = binexpr_int(0, TT_LEFT_CURLY);

  00319	6a 0b		 push	 11			; 0000000bH
  0031b	6a 00		 push	 0
  0031d	e8 00 00 00 00	 call	 _binexpr_int
  00322	83 c4 08	 add	 esp, 8
  00325	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  00328	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0032b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 422  : 		node->left->right = genMainAST(scope_depth);

  0032e	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00331	50		 push	 eax
  00332	e8 00 00 00 00	 call	 _genMainAST
  00337	83 c4 04	 add	 esp, 4
  0033a	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  0033d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00340	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 423  : 		node->right = genMainAST(scope_depth);

  00343	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00346	50		 push	 eax
  00347	e8 00 00 00 00	 call	 _genMainAST
  0034c	83 c4 04	 add	 esp, 4
  0034f	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  00352	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 424  : 		return node;

  00355	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  00358	e9 3d 01 00 00	 jmp	 $LN1@genMainAST

; 425  : 		break;

  0035d	e9 db 00 00 00	 jmp	 $LN2@genMainAST
$LN14@genMainAST:

; 426  :      
; 427  : 
; 428  : 	///////////////////////////////////////////////////////////////////
; 429  : 	//    SCOPE
; 430  : 	///////////////////////////////////////////////////////////////////
; 431  : 
; 432  : 	case TT_LEFT_CURLY:
; 433  : 		globl_open_curly_count++;

  00362	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_open_curly_count
  00367	83 c0 01	 add	 eax, 1
  0036a	a3 00 00 00 00	 mov	 DWORD PTR _globl_open_curly_count, eax

; 434  : 		globl_current_depth = globl_open_curly_count - globl_closed_curly_count;

  0036f	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_open_curly_count
  00374	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _globl_closed_curly_count
  0037a	a3 00 00 00 00	 mov	 DWORD PTR _globl_current_depth, eax

; 435  : 		if (globl_current_depth == (scope_depth + 1))

  0037f	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00382	83 c0 01	 add	 eax, 1
  00385	39 05 00 00 00
	00		 cmp	 DWORD PTR _globl_current_depth, eax
  0038b	75 40		 jne	 SHORT $LN15@genMainAST

; 436  : 		{
; 437  : 			node = mkastnode(TT_SCOPE, 0, 0, NULL, NULL, NULL, NULL);

  0038d	6a 00		 push	 0
  0038f	6a 00		 push	 0
  00391	6a 00		 push	 0
  00393	6a 00		 push	 0
  00395	83 ec 08	 sub	 esp, 8
  00398	0f 57 c0	 xorps	 xmm0, xmm0
  0039b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003a0	6a 00		 push	 0
  003a2	6a 00		 push	 0
  003a4	6a 21		 push	 33			; 00000021H
  003a6	e8 00 00 00 00	 call	 _mkastnode
  003ab	83 c4 24	 add	 esp, 36			; 00000024H
  003ae	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 438  : 			node->left = genMainAST(globl_current_depth);

  003b1	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_current_depth
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 _genMainAST
  003bc	83 c4 04	 add	 esp, 4
  003bf	8b 4d e0	 mov	 ecx, DWORD PTR _node$[ebp]
  003c2	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 439  : 			//node->right = genMainAST(scope_depth);
; 440  : 			return node;

  003c5	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  003c8	e9 cd 00 00 00	 jmp	 $LN1@genMainAST
$LN15@genMainAST:

; 441  : 		}
; 442  : 		break;

  003cd	eb 6e		 jmp	 SHORT $LN2@genMainAST
$LN16@genMainAST:

; 443  : 
; 444  : 	case TT_RIGHT_CURLY:
; 445  : 		globl_closed_curly_count++;

  003cf	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_closed_curly_count
  003d4	83 c0 01	 add	 eax, 1
  003d7	a3 00 00 00 00	 mov	 DWORD PTR _globl_closed_curly_count, eax

; 446  : 		globl_current_depth = globl_open_curly_count - globl_closed_curly_count;

  003dc	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_open_curly_count
  003e1	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR _globl_closed_curly_count
  003e7	a3 00 00 00 00	 mov	 DWORD PTR _globl_current_depth, eax

; 447  : 		if (globl_current_depth == (scope_depth -1))

  003ec	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  003ef	83 e8 01	 sub	 eax, 1
  003f2	39 05 00 00 00
	00		 cmp	 DWORD PTR _globl_current_depth, eax
  003f8	75 43		 jne	 SHORT $LN17@genMainAST

; 448  : 		{
; 449  : 			globl_open_curly_count -= 1;

  003fa	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_open_curly_count
  003ff	83 e8 01	 sub	 eax, 1
  00402	a3 00 00 00 00	 mov	 DWORD PTR _globl_open_curly_count, eax

; 450  : 			globl_closed_curly_count -= 1;

  00407	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_closed_curly_count
  0040c	83 e8 01	 sub	 eax, 1
  0040f	a3 00 00 00 00	 mov	 DWORD PTR _globl_closed_curly_count, eax

; 451  : 			node = mkastnode(TT_SCOPE_END, 0, 0, NULL, NULL, NULL, NULL);

  00414	6a 00		 push	 0
  00416	6a 00		 push	 0
  00418	6a 00		 push	 0
  0041a	6a 00		 push	 0
  0041c	83 ec 08	 sub	 esp, 8
  0041f	0f 57 c0	 xorps	 xmm0, xmm0
  00422	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00427	6a 00		 push	 0
  00429	6a 00		 push	 0
  0042b	6a 22		 push	 34			; 00000022H
  0042d	e8 00 00 00 00	 call	 _mkastnode
  00432	83 c4 24	 add	 esp, 36			; 00000024H
  00435	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 452  : 			return node;

  00438	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
  0043b	eb 5d		 jmp	 SHORT $LN1@genMainAST
$LN17@genMainAST:
$LN2@genMainAST:

; 453  : 		}
; 454  : 		break;
; 455  : 
; 456  : 	/////////////////////////////////////////////////////////////////////
; 457  : 
; 458  : 
; 459  : 	}
; 460  : 	if (currentToken->tokenType == TT_EOF)

  0043d	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00442	83 38 11	 cmp	 DWORD PTR [eax], 17	; 00000011H
  00445	75 09		 jne	 SHORT $LN18@genMainAST

; 461  : 	{
; 462  : 		right = NULL;

  00447	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _right$[ebp], 0

; 463  : 	}

  0044e	eb 0f		 jmp	 SHORT $LN19@genMainAST
$LN18@genMainAST:

; 464  : 	else
; 465  : 	{
; 466  : 		right = genMainAST(scope_depth);

  00450	8b 45 08	 mov	 eax, DWORD PTR _scope_depth$[ebp]
  00453	50		 push	 eax
  00454	e8 00 00 00 00	 call	 _genMainAST
  00459	83 c4 04	 add	 esp, 4
  0045c	89 45 ec	 mov	 DWORD PTR _right$[ebp], eax
$LN19@genMainAST:

; 467  : 	}
; 468  : 	node = mkastnode(t->tokenType, t->intValue, t->floatVal, left, right, NULL, NULL);

  0045f	6a 00		 push	 0
  00461	6a 00		 push	 0
  00463	8b 45 ec	 mov	 eax, DWORD PTR _right$[ebp]
  00466	50		 push	 eax
  00467	8b 4d f8	 mov	 ecx, DWORD PTR _left$[ebp]
  0046a	51		 push	 ecx
  0046b	8b 55 d4	 mov	 edx, DWORD PTR _t$[ebp]
  0046e	83 ec 08	 sub	 esp, 8
  00471	f2 0f 10 42 18	 movsd	 xmm0, QWORD PTR [edx+24]
  00476	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0047b	8b 45 d4	 mov	 eax, DWORD PTR _t$[ebp]
  0047e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00481	51		 push	 ecx
  00482	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00485	52		 push	 edx
  00486	8b 45 d4	 mov	 eax, DWORD PTR _t$[ebp]
  00489	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048b	51		 push	 ecx
  0048c	e8 00 00 00 00	 call	 _mkastnode
  00491	83 c4 24	 add	 esp, 36			; 00000024H
  00494	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 469  : 	return node;

  00497	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
$LN1@genMainAST:

; 470  : }

  0049a	5f		 pop	 edi
  0049b	5e		 pop	 esi
  0049c	5b		 pop	 ebx
  0049d	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  004a3	3b ec		 cmp	 ebp, esp
  004a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004aa	8b e5		 mov	 esp, ebp
  004ac	5d		 pop	 ebp
  004ad	c3		 ret	 0
  004ae	66 90		 npad	 2
$LN22@genMainAST:
  004b0	00 00 00 00	 DD	 $LN4@genMainAST
  004b4	00 00 00 00	 DD	 $LN12@genMainAST
  004b8	00 00 00 00	 DD	 $LN14@genMainAST
  004bc	00 00 00 00	 DD	 $LN16@genMainAST
  004c0	00 00 00 00	 DD	 $LN8@genMainAST
  004c4	00 00 00 00	 DD	 $LN7@genMainAST
  004c8	00 00 00 00	 DD	 $LN9@genMainAST
  004cc	00 00 00 00	 DD	 $LN2@genMainAST
$LN21@genMainAST:
  004d0	00		 DB	 0
  004d1	01		 DB	 1
  004d2	07		 DB	 7
  004d3	07		 DB	 7
  004d4	02		 DB	 2
  004d5	03		 DB	 3
  004d6	07		 DB	 7
  004d7	07		 DB	 7
  004d8	07		 DB	 7
  004d9	07		 DB	 7
  004da	07		 DB	 7
  004db	04		 DB	 4
  004dc	07		 DB	 7
  004dd	05		 DB	 5
  004de	06		 DB	 6
_genMainAST ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _binexpr_int
_TEXT	SEGMENT
_saveIdentName$1 = -128					; size = 4
_lastToken$2 = -116					; size = 4
_lastLine$ = -104					; size = 4
_boolVal$3 = -92					; size = 4
_boolVal$4 = -80					; size = 4
_saveIdentName$5 = -68					; size = 4
_minusToken$ = -56					; size = 4
_minusVal$ = -44					; size = 4
_right$ = -32						; size = 4
_left$ = -20						; size = 4
_k$ = -8						; size = 4
_ptp$ = 8						; size = 4
_interrupt_token$ = 12					; size = 4
_binexpr_int PROC					; COMDAT

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd bc fe ff
	ff		 lea	 edi, DWORD PTR [ebp-324]
  00012	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 209  : 	int k = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 210  : 	struct  AST_Node* left, * right;
; 211  : 	scan_curToken(); // int or float

  0002f	e8 00 00 00 00	 call	 _scan_curToken

; 212  : 	int minusVal = 1;

  00034	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _minusVal$[ebp], 1

; 213  : 	struct Token* minusToken = currentToken;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00040	89 45 c8	 mov	 DWORD PTR _minusToken$[ebp], eax
$LN2@binexpr_in:

; 214  : 	while (currentToken->tokenType == TT_MINUS)

  00043	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00048	83 38 01	 cmp	 DWORD PTR [eax], 1
  0004b	75 0e		 jne	 SHORT $LN3@binexpr_in

; 215  : 	{
; 216  : 		minusVal *= -1;

  0004d	6b 45 d4 ff	 imul	 eax, DWORD PTR _minusVal$[ebp], -1
  00051	89 45 d4	 mov	 DWORD PTR _minusVal$[ebp], eax

; 217  : 		scan_curToken();

  00054	e8 00 00 00 00	 call	 _scan_curToken

; 218  : 	}

  00059	eb e8		 jmp	 SHORT $LN2@binexpr_in
$LN3@binexpr_in:

; 219  : 	leftParenCode(minusToken);

  0005b	8b 45 c8	 mov	 eax, DWORD PTR _minusToken$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 _leftParenCode
  00064	83 c4 04	 add	 esp, 4

; 220  : 
; 221  : 	if (currentToken->tokenType != TT_INT && currentToken->tokenType != TT_FLOAT && currentToken->tokenType != TT_IDENT && currentToken->tokenType != TT_BOOL_TRUE && currentToken->tokenType != TT_BOOL_FALSE)

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0006c	83 38 05	 cmp	 DWORD PTR [eax], 5
  0006f	74 4c		 je	 SHORT $LN6@binexpr_in
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00076	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  00079	74 42		 je	 SHORT $LN6@binexpr_in
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00080	83 38 12	 cmp	 DWORD PTR [eax], 18	; 00000012H
  00083	74 38		 je	 SHORT $LN6@binexpr_in
  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0008a	83 38 1f	 cmp	 DWORD PTR [eax], 31	; 0000001fH
  0008d	74 2e		 je	 SHORT $LN6@binexpr_in
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00094	83 38 20	 cmp	 DWORD PTR [eax], 32	; 00000020H
  00097	74 24		 je	 SHORT $LN6@binexpr_in

; 222  : 	{
; 223  : 		printf("[SYNTAX ERROR] expected a number (Line %d)", Line);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@
  000a4	e8 00 00 00 00	 call	 _printf
  000a9	83 c4 08	 add	 esp, 8

; 224  : 		exit(1);

  000ac	8b f4		 mov	 esi, esp
  000ae	6a 01		 push	 1
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000b6	3b f4		 cmp	 esi, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@binexpr_in:

; 225  : 	}
; 226  : 	if (currentToken->data != NULL)

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000c2	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  000c6	74 0e		 je	 SHORT $LN7@binexpr_in

; 227  : 	{
; 228  : 		currentToken->data->minusVal = minusVal;

  000c8	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000cd	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000d0	8b 55 d4	 mov	 edx, DWORD PTR _minusVal$[ebp]
  000d3	89 51 18	 mov	 DWORD PTR [ecx+24], edx
$LN7@binexpr_in:

; 229  : 	}
; 230  : 	left = mkastnode_const(currentToken->tokenType, currentToken->intValue * minusVal, currentToken->floatVal * minusVal, NULL, currentToken->data);

  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000db	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000de	51		 push	 ecx
  000df	6a 00		 push	 0
  000e1	f2 0f 2a 45 d4	 cvtsi2sd xmm0, DWORD PTR _minusVal$[ebp]
  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _currentToken
  000ec	f2 0f 59 42 18	 mulsd	 xmm0, QWORD PTR [edx+24]
  000f1	83 ec 08	 sub	 esp, 8
  000f4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000f9	8b 45 d4	 mov	 eax, DWORD PTR _minusVal$[ebp]
  000fc	99		 cdq
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  00103	52		 push	 edx
  00104	50		 push	 eax
  00105	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00108	52		 push	 edx
  00109	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 __allmul
  00112	52		 push	 edx
  00113	50		 push	 eax
  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  0011a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011c	52		 push	 edx
  0011d	e8 00 00 00 00	 call	 _mkastnode_const
  00122	83 c4 1c	 add	 esp, 28			; 0000001cH
  00125	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax

; 231  : 	if (currentToken->tokenType == TT_IDENT)

  00128	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0012d	83 38 12	 cmp	 DWORD PTR [eax], 18	; 00000012H
  00130	0f 85 9d 00 00
	00		 jne	 $LN8@binexpr_in

; 232  : 	{
; 233  : 		char* saveIdentName = calloc(strlen(currentToken->IdentToken_name), sizeof(char));

  00136	8b f4		 mov	 esi, esp
  00138	6a 01		 push	 1
  0013a	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0013f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 _strlen
  00148	83 c4 04	 add	 esp, 4
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00152	83 c4 08	 add	 esp, 8
  00155	3b f4		 cmp	 esi, esp
  00157	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015c	89 45 bc	 mov	 DWORD PTR _saveIdentName$5[ebp], eax

; 234  : 		saveIdentName = strcpy(saveIdentName, currentToken->IdentToken_name);

  0015f	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00164	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00167	51		 push	 ecx
  00168	8b 55 bc	 mov	 edx, DWORD PTR _saveIdentName$5[ebp]
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 _strcpy
  00171	83 c4 08	 add	 esp, 8
  00174	89 45 bc	 mov	 DWORD PTR _saveIdentName$5[ebp], eax

; 235  : 		left = mkastnode_ident(TT_IDENT, minusVal, minusVal, NULL, NULL, newID_token(DT_INT, 1, 0, saveIdentName, 0, new_DATA_STRUCT(NULL, NULL, NULL, NULL, NULL, -1, minusVal)), saveIdentName, NULL);

  00177	6a 00		 push	 0
  00179	8b 45 bc	 mov	 eax, DWORD PTR _saveIdentName$5[ebp]
  0017c	50		 push	 eax
  0017d	8b 4d d4	 mov	 ecx, DWORD PTR _minusVal$[ebp]
  00180	51		 push	 ecx
  00181	6a ff		 push	 -1
  00183	6a 00		 push	 0
  00185	6a 00		 push	 0
  00187	6a 00		 push	 0
  00189	6a 00		 push	 0
  0018b	6a 00		 push	 0
  0018d	6a 00		 push	 0
  0018f	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  00194	83 c4 20	 add	 esp, 32			; 00000020H
  00197	50		 push	 eax
  00198	6a 00		 push	 0
  0019a	8b 55 bc	 mov	 edx, DWORD PTR _saveIdentName$5[ebp]
  0019d	52		 push	 edx
  0019e	6a 00		 push	 0
  001a0	6a 00		 push	 0
  001a2	6a 01		 push	 1
  001a4	6a 00		 push	 0
  001a6	e8 00 00 00 00	 call	 _newID_token
  001ab	83 c4 1c	 add	 esp, 28			; 0000001cH
  001ae	50		 push	 eax
  001af	6a 00		 push	 0
  001b1	6a 00		 push	 0
  001b3	f2 0f 2a 45 d4	 cvtsi2sd xmm0, DWORD PTR _minusVal$[ebp]
  001b8	83 ec 08	 sub	 esp, 8
  001bb	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001c0	8b 45 d4	 mov	 eax, DWORD PTR _minusVal$[ebp]
  001c3	99		 cdq
  001c4	52		 push	 edx
  001c5	50		 push	 eax
  001c6	6a 12		 push	 18			; 00000012H
  001c8	e8 00 00 00 00	 call	 _mkastnode_ident
  001cd	83 c4 28	 add	 esp, 40			; 00000028H
  001d0	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN8@binexpr_in:

; 236  : 	}
; 237  : 	if (currentToken->tokenType == TT_BOOL_TRUE)

  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  001d8	83 38 1f	 cmp	 DWORD PTR [eax], 31	; 0000001fH
  001db	75 5d		 jne	 SHORT $LN9@binexpr_in

; 238  : 	{
; 239  : 		int* boolVal = malloc(sizeof(int));

  001dd	8b f4		 mov	 esi, esp
  001df	6a 04		 push	 4
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001e7	83 c4 04	 add	 esp, 4
  001ea	3b f4		 cmp	 esi, esp
  001ec	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f1	89 45 b0	 mov	 DWORD PTR _boolVal$4[ebp], eax

; 240  : 		*boolVal = 1;

  001f4	8b 45 b0	 mov	 eax, DWORD PTR _boolVal$4[ebp]
  001f7	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 241  : 		left = mkastnode(TT_BOOL_TRUE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, boolVal, NULL, NULL, NULL, DT_BOOL, 1));

  001fd	6a 01		 push	 1
  001ff	6a 05		 push	 5
  00201	6a 00		 push	 0
  00203	6a 00		 push	 0
  00205	6a 00		 push	 0
  00207	6a 00		 push	 0
  00209	8b 45 b0	 mov	 eax, DWORD PTR _boolVal$4[ebp]
  0020c	50		 push	 eax
  0020d	6a 00		 push	 0
  0020f	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  00214	83 c4 20	 add	 esp, 32			; 00000020H
  00217	50		 push	 eax
  00218	6a 00		 push	 0
  0021a	6a 00		 push	 0
  0021c	6a 00		 push	 0
  0021e	83 ec 08	 sub	 esp, 8
  00221	0f 57 c0	 xorps	 xmm0, xmm0
  00224	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	6a 1f		 push	 31			; 0000001fH
  0022f	e8 00 00 00 00	 call	 _mkastnode
  00234	83 c4 24	 add	 esp, 36			; 00000024H
  00237	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN9@binexpr_in:

; 242  : 	}
; 243  : 	if (currentToken->tokenType == TT_BOOL_FALSE)

  0023a	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0023f	83 38 20	 cmp	 DWORD PTR [eax], 32	; 00000020H
  00242	75 5d		 jne	 SHORT $LN10@binexpr_in

; 244  : 	{
; 245  : 		int* boolVal = malloc(sizeof(int));

  00244	8b f4		 mov	 esi, esp
  00246	6a 04		 push	 4
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0024e	83 c4 04	 add	 esp, 4
  00251	3b f4		 cmp	 esi, esp
  00253	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00258	89 45 a4	 mov	 DWORD PTR _boolVal$3[ebp], eax

; 246  : 		*boolVal = 0;

  0025b	8b 45 a4	 mov	 eax, DWORD PTR _boolVal$3[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 247  : 		left = mkastnode(TT_BOOL_FALSE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, boolVal, NULL, NULL, NULL, DT_BOOL, 1));

  00264	6a 01		 push	 1
  00266	6a 05		 push	 5
  00268	6a 00		 push	 0
  0026a	6a 00		 push	 0
  0026c	6a 00		 push	 0
  0026e	6a 00		 push	 0
  00270	8b 45 a4	 mov	 eax, DWORD PTR _boolVal$3[ebp]
  00273	50		 push	 eax
  00274	6a 00		 push	 0
  00276	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  0027b	83 c4 20	 add	 esp, 32			; 00000020H
  0027e	50		 push	 eax
  0027f	6a 00		 push	 0
  00281	6a 00		 push	 0
  00283	6a 00		 push	 0
  00285	83 ec 08	 sub	 esp, 8
  00288	0f 57 c0	 xorps	 xmm0, xmm0
  0028b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00290	6a 00		 push	 0
  00292	6a 00		 push	 0
  00294	6a 20		 push	 32			; 00000020H
  00296	e8 00 00 00 00	 call	 _mkastnode
  0029b	83 c4 24	 add	 esp, 36			; 00000024H
  0029e	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN10@binexpr_in:

; 248  : 	}
; 249  : 	minusVal = 1;

  002a1	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _minusVal$[ebp], 1

; 250  : 	int lastLine = Line;

  002a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  002ad	89 45 98	 mov	 DWORD PTR _lastLine$[ebp], eax

; 251  : 	scan_curToken(); // bin operator

  002b0	e8 00 00 00 00	 call	 _scan_curToken

; 252  : 
; 253  : 
; 254  : 
; 255  : 	if (rightParenCode(interrupt_token) == 1)

  002b5	8b 45 0c	 mov	 eax, DWORD PTR _interrupt_token$[ebp]
  002b8	50		 push	 eax
  002b9	e8 00 00 00 00	 call	 _rightParenCode
  002be	83 c4 04	 add	 esp, 4
  002c1	83 f8 01	 cmp	 eax, 1
  002c4	75 08		 jne	 SHORT $LN11@binexpr_in

; 256  : 	{
; 257  : 		return left;

  002c6	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
  002c9	e9 84 02 00 00	 jmp	 $LN1@binexpr_in
$LN11@binexpr_in:

; 258  : 	}
; 259  : 
; 260  : 
; 261  : 	if (tokenIsBinOp(currentToken) == 0)

  002ce	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  002d3	50		 push	 eax
  002d4	e8 00 00 00 00	 call	 _tokenIsBinOp
  002d9	83 c4 04	 add	 esp, 4
  002dc	85 c0		 test	 eax, eax
  002de	75 22		 jne	 SHORT $LN12@binexpr_in

; 262  : 	{
; 263  : 		printf("[SYNTAX ERROR] expected a binary operator or ';' (Line %d)\n", lastLine);

  002e0	8b 45 98	 mov	 eax, DWORD PTR _lastLine$[ebp]
  002e3	50		 push	 eax
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
  002e9	e8 00 00 00 00	 call	 _printf
  002ee	83 c4 08	 add	 esp, 8

; 264  : 		exit(1);

  002f1	8b f4		 mov	 esi, esp
  002f3	6a 01		 push	 1
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  002fb	3b f4		 cmp	 esi, esp
  002fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@binexpr_in:

; 265  : 	}
; 266  : 	if (currentToken->tokenType == TT_EOF)

  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00307	83 38 11	 cmp	 DWORD PTR [eax], 17	; 00000011H
  0030a	75 22		 jne	 SHORT $LN13@binexpr_in

; 267  : 	{
; 268  : 		printf("[SYNTAX ERROR] expected a ';' in Line %d\n", lastLine);

  0030c	8b 45 98	 mov	 eax, DWORD PTR _lastLine$[ebp]
  0030f	50		 push	 eax
  00310	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
  00315	e8 00 00 00 00	 call	 _printf
  0031a	83 c4 08	 add	 esp, 8

; 269  : 		exit(1);

  0031d	8b f4		 mov	 esi, esp
  0031f	6a 01		 push	 1
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00327	3b f4		 cmp	 esi, esp
  00329	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN13@binexpr_in:

; 270  : 	}
; 271  : 	if (currentToken->tokenType == TT_OP_END)

  0032e	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00333	83 38 06	 cmp	 DWORD PTR [eax], 6
  00336	75 32		 jne	 SHORT $LN14@binexpr_in

; 272  : 	{
; 273  : 		if (interrupt_token == INTERRUPT_TOKEN_DEFAULT)

  00338	83 7d 0c ff	 cmp	 DWORD PTR _interrupt_token$[ebp], -1
  0033c	75 08		 jne	 SHORT $LN15@binexpr_in

; 274  : 		{
; 275  : 			return left;

  0033e	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
  00341	e9 0c 02 00 00	 jmp	 $LN1@binexpr_in
$LN15@binexpr_in:

; 276  : 		}
; 277  : 		printf("[SYNTAX ERROR] cannot use ';' inside an expression (Line %d)\n", Line);

  00346	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0034b	50		 push	 eax
  0034c	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@
  00351	e8 00 00 00 00	 call	 _printf
  00356	83 c4 08	 add	 esp, 8

; 278  : 		exit(1);

  00359	8b f4		 mov	 esi, esp
  0035b	6a 01		 push	 1
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00363	3b f4		 cmp	 esi, esp
  00365	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@binexpr_in:

; 279  : 	}
; 280  : 
; 281  : 	while (getOpPrecedence(currentToken) + globl_inParen * globl_parenDelta > ptp)

  0036a	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0036f	50		 push	 eax
  00370	e8 00 00 00 00	 call	 _getOpPrecedence
  00375	83 c4 04	 add	 esp, 4
  00378	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _globl_inParen
  0037e	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _globl_parenDelta
  00385	03 c1		 add	 eax, ecx
  00387	3b 45 08	 cmp	 eax, DWORD PTR _ptp$[ebp]
  0038a	0f 8e bf 01 00
	00		 jle	 $LN5@binexpr_in

; 282  : 	{
; 283  : 		struct Token* lastToken = currentToken;

  00390	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00395	89 45 8c	 mov	 DWORD PTR _lastToken$2[ebp], eax

; 284  : 		right = binexpr_int(getOpPrecedence(currentToken) + globl_inParen * globl_parenDelta, interrupt_token);

  00398	8b 45 0c	 mov	 eax, DWORD PTR _interrupt_token$[ebp]
  0039b	50		 push	 eax
  0039c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  003a2	51		 push	 ecx
  003a3	e8 00 00 00 00	 call	 _getOpPrecedence
  003a8	83 c4 04	 add	 esp, 4
  003ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _globl_inParen
  003b1	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR _globl_parenDelta
  003b8	03 c2		 add	 eax, edx
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 _binexpr_int
  003c0	83 c4 08	 add	 esp, 8
  003c3	89 45 e0	 mov	 DWORD PTR _right$[ebp], eax

; 285  : 		left = mkastnode(lastToken->tokenType, lastToken->intValue, lastToken->floatVal, left, right, NULL, lastToken->data);

  003c6	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  003c9	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  003cc	51		 push	 ecx
  003cd	6a 00		 push	 0
  003cf	8b 55 e0	 mov	 edx, DWORD PTR _right$[ebp]
  003d2	52		 push	 edx
  003d3	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
  003d6	50		 push	 eax
  003d7	8b 4d 8c	 mov	 ecx, DWORD PTR _lastToken$2[ebp]
  003da	83 ec 08	 sub	 esp, 8
  003dd	f2 0f 10 41 18	 movsd	 xmm0, QWORD PTR [ecx+24]
  003e2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003e7	8b 55 8c	 mov	 edx, DWORD PTR _lastToken$2[ebp]
  003ea	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  003ed	50		 push	 eax
  003ee	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  003f1	51		 push	 ecx
  003f2	8b 55 8c	 mov	 edx, DWORD PTR _lastToken$2[ebp]
  003f5	8b 02		 mov	 eax, DWORD PTR [edx]
  003f7	50		 push	 eax
  003f8	e8 00 00 00 00	 call	 _mkastnode
  003fd	83 c4 24	 add	 esp, 36			; 00000024H
  00400	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax

; 286  : 		if (lastToken->tokenType == TT_IDENT)

  00403	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  00406	83 38 12	 cmp	 DWORD PTR [eax], 18	; 00000012H
  00409	0f 85 a9 00 00
	00		 jne	 $LN16@binexpr_in

; 287  : 		{
; 288  : 			char* saveIdentName = calloc(strlen(lastToken->IdentToken_name), sizeof(char));

  0040f	8b f4		 mov	 esi, esp
  00411	6a 01		 push	 1
  00413	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  00416	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00419	51		 push	 ecx
  0041a	e8 00 00 00 00	 call	 _strlen
  0041f	83 c4 04	 add	 esp, 4
  00422	50		 push	 eax
  00423	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00429	83 c4 08	 add	 esp, 8
  0042c	3b f4		 cmp	 esi, esp
  0042e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00433	89 45 80	 mov	 DWORD PTR _saveIdentName$1[ebp], eax

; 289  : 			saveIdentName = strcpy(saveIdentName, lastToken->IdentToken_name);

  00436	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  00439	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0043c	51		 push	 ecx
  0043d	8b 55 80	 mov	 edx, DWORD PTR _saveIdentName$1[ebp]
  00440	52		 push	 edx
  00441	e8 00 00 00 00	 call	 _strcpy
  00446	83 c4 08	 add	 esp, 8
  00449	89 45 80	 mov	 DWORD PTR _saveIdentName$1[ebp], eax

; 290  : 			left = mkastnode_ident(lastToken->tokenType, lastToken->intValue, lastToken->floatVal, left, right, newID_token(DT_INT, 1, 0, saveIdentName, 0, new_DATA_STRUCT(NULL, NULL, NULL, NULL, NULL, -1, minusVal)), saveIdentName, NULL);

  0044c	6a 00		 push	 0
  0044e	8b 45 80	 mov	 eax, DWORD PTR _saveIdentName$1[ebp]
  00451	50		 push	 eax
  00452	8b 4d d4	 mov	 ecx, DWORD PTR _minusVal$[ebp]
  00455	51		 push	 ecx
  00456	6a ff		 push	 -1
  00458	6a 00		 push	 0
  0045a	6a 00		 push	 0
  0045c	6a 00		 push	 0
  0045e	6a 00		 push	 0
  00460	6a 00		 push	 0
  00462	6a 00		 push	 0
  00464	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  00469	83 c4 20	 add	 esp, 32			; 00000020H
  0046c	50		 push	 eax
  0046d	6a 00		 push	 0
  0046f	8b 55 80	 mov	 edx, DWORD PTR _saveIdentName$1[ebp]
  00472	52		 push	 edx
  00473	6a 00		 push	 0
  00475	6a 00		 push	 0
  00477	6a 01		 push	 1
  00479	6a 00		 push	 0
  0047b	e8 00 00 00 00	 call	 _newID_token
  00480	83 c4 1c	 add	 esp, 28			; 0000001cH
  00483	50		 push	 eax
  00484	8b 45 e0	 mov	 eax, DWORD PTR _right$[ebp]
  00487	50		 push	 eax
  00488	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  0048b	51		 push	 ecx
  0048c	8b 55 8c	 mov	 edx, DWORD PTR _lastToken$2[ebp]
  0048f	83 ec 08	 sub	 esp, 8
  00492	f2 0f 10 42 18	 movsd	 xmm0, QWORD PTR [edx+24]
  00497	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0049c	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  0049f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  004a2	51		 push	 ecx
  004a3	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  004a6	52		 push	 edx
  004a7	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  004aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ac	51		 push	 ecx
  004ad	e8 00 00 00 00	 call	 _mkastnode_ident
  004b2	83 c4 28	 add	 esp, 40			; 00000028H
  004b5	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN16@binexpr_in:

; 291  : 		}
; 292  : 		if (lastToken->tokenType == TT_BOOL_TRUE)

  004b8	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  004bb	83 38 1f	 cmp	 DWORD PTR [eax], 31	; 0000001fH
  004be	75 3b		 jne	 SHORT $LN17@binexpr_in

; 293  : 		{
; 294  : 			left = mkastnode(TT_BOOL_TRUE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, 1, NULL, NULL, NULL, DT_BOOL, 1));

  004c0	6a 01		 push	 1
  004c2	6a 05		 push	 5
  004c4	6a 00		 push	 0
  004c6	6a 00		 push	 0
  004c8	6a 00		 push	 0
  004ca	6a 00		 push	 0
  004cc	6a 01		 push	 1
  004ce	6a 00		 push	 0
  004d0	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  004d5	83 c4 20	 add	 esp, 32			; 00000020H
  004d8	50		 push	 eax
  004d9	6a 00		 push	 0
  004db	6a 00		 push	 0
  004dd	6a 00		 push	 0
  004df	83 ec 08	 sub	 esp, 8
  004e2	0f 57 c0	 xorps	 xmm0, xmm0
  004e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  004ea	6a 00		 push	 0
  004ec	6a 00		 push	 0
  004ee	6a 1f		 push	 31			; 0000001fH
  004f0	e8 00 00 00 00	 call	 _mkastnode
  004f5	83 c4 24	 add	 esp, 36			; 00000024H
  004f8	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN17@binexpr_in:

; 295  : 		}
; 296  : 		if (lastToken->tokenType == TT_BOOL_FALSE)

  004fb	8b 45 8c	 mov	 eax, DWORD PTR _lastToken$2[ebp]
  004fe	83 38 20	 cmp	 DWORD PTR [eax], 32	; 00000020H
  00501	75 3b		 jne	 SHORT $LN18@binexpr_in

; 297  : 		{
; 298  : 			left = mkastnode(TT_BOOL_FALSE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, 0, NULL, NULL, NULL, DT_BOOL, 1));

  00503	6a 01		 push	 1
  00505	6a 05		 push	 5
  00507	6a 00		 push	 0
  00509	6a 00		 push	 0
  0050b	6a 00		 push	 0
  0050d	6a 00		 push	 0
  0050f	6a 00		 push	 0
  00511	6a 00		 push	 0
  00513	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  00518	83 c4 20	 add	 esp, 32			; 00000020H
  0051b	50		 push	 eax
  0051c	6a 00		 push	 0
  0051e	6a 00		 push	 0
  00520	6a 00		 push	 0
  00522	83 ec 08	 sub	 esp, 8
  00525	0f 57 c0	 xorps	 xmm0, xmm0
  00528	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0052d	6a 00		 push	 0
  0052f	6a 00		 push	 0
  00531	6a 20		 push	 32			; 00000020H
  00533	e8 00 00 00 00	 call	 _mkastnode
  00538	83 c4 24	 add	 esp, 36			; 00000024H
  0053b	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax
$LN18@binexpr_in:

; 299  : 		}
; 300  : 
; 301  : 		rightParenCode(interrupt_token);

  0053e	8b 45 0c	 mov	 eax, DWORD PTR _interrupt_token$[ebp]
  00541	50		 push	 eax
  00542	e8 00 00 00 00	 call	 _rightParenCode
  00547	83 c4 04	 add	 esp, 4

; 302  : 	}

  0054a	e9 1b fe ff ff	 jmp	 $LN14@binexpr_in
$LN5@binexpr_in:

; 303  : 	return left;

  0054f	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
$LN1@binexpr_in:

; 304  : }

  00552	5f		 pop	 edi
  00553	5e		 pop	 esi
  00554	5b		 pop	 ebx
  00555	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  0055b	3b ec		 cmp	 ebp, esp
  0055d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00562	8b e5		 mov	 esp, ebp
  00564	5d		 pop	 ebp
  00565	c3		 ret	 0
_binexpr_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _binexpr
_TEXT	SEGMENT
_thisToken$ = -44					; size = 4
_node$ = -32						; size = 4
_right$ = -20						; size = 4
_left$ = -8						; size = 4
_binexpr PROC						; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 310  : 	struct AST_Node* left, * right, * node;
; 311  : 	scan_curToken();

  00028	e8 00 00 00 00	 call	 _scan_curToken

; 312  : 	if (currentToken->tokenType != TT_INT && currentToken->tokenType != TT_FLOAT)

  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  00032	83 38 05	 cmp	 DWORD PTR [eax], 5
  00035	74 2e		 je	 SHORT $LN2@binexpr
  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0003c	83 38 10	 cmp	 DWORD PTR [eax], 16	; 00000010H
  0003f	74 24		 je	 SHORT $LN2@binexpr

; 313  : 	{
; 314  : 		printf("[SYNTAX ERROR] expected a number (Line %d)", Line);

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@
  0004c	e8 00 00 00 00	 call	 _printf
  00051	83 c4 08	 add	 esp, 8

; 315  : 		exit(1);

  00054	8b f4		 mov	 esi, esp
  00056	6a 01		 push	 1
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@binexpr:

; 316  : 	}
; 317  : 	left = mkastnode_const(currentToken->tokenType, currentToken->intValue, currentToken->floatVal, NULL, NULL);

  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  0006e	83 ec 08	 sub	 esp, 8
  00071	f2 0f 10 40 18	 movsd	 xmm0, QWORD PTR [eax+24]
  00076	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  00081	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00084	52		 push	 edx
  00085	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00088	50		 push	 eax
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _currentToken
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _mkastnode_const
  00097	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009a	89 45 f8	 mov	 DWORD PTR _left$[ebp], eax

; 318  : 	scan_curToken();

  0009d	e8 00 00 00 00	 call	 _scan_curToken

; 319  : 	if (tokenIsBinOp(currentToken) == 0)

  000a2	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _tokenIsBinOp
  000ad	83 c4 04	 add	 esp, 4
  000b0	85 c0		 test	 eax, eax
  000b2	75 24		 jne	 SHORT $LN3@binexpr

; 320  : 	{
; 321  : 		printf("[SYNTAX ERROR] expected a binary operator (Line %d)\n", Line);

  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NLEHDODD@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
  000bf	e8 00 00 00 00	 call	 _printf
  000c4	83 c4 08	 add	 esp, 8

; 322  : 		exit(1);

  000c7	8b f4		 mov	 esi, esp
  000c9	6a 01		 push	 1
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000d1	3b f4		 cmp	 esi, esp
  000d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@binexpr:

; 323  : 	}
; 324  : 	struct Token* thisToken = currentToken;

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000dd	89 45 d4	 mov	 DWORD PTR _thisToken$[ebp], eax

; 325  : 	if (thisToken->tokenType == TT_OP_END)

  000e0	8b 45 d4	 mov	 eax, DWORD PTR _thisToken$[ebp]
  000e3	83 38 06	 cmp	 DWORD PTR [eax], 6
  000e6	75 05		 jne	 SHORT $LN4@binexpr

; 326  : 	{
; 327  : 		return left;

  000e8	8b 45 f8	 mov	 eax, DWORD PTR _left$[ebp]
  000eb	eb 71		 jmp	 SHORT $LN1@binexpr
$LN4@binexpr:

; 328  : 	}
; 329  : 	if (currentToken->tokenType == TT_EOF)

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR _currentToken
  000f2	83 38 11	 cmp	 DWORD PTR [eax], 17	; 00000011H
  000f5	75 24		 jne	 SHORT $LN5@binexpr

; 330  : 	{
; 331  : 		printf("[SYNTAX ERROR] expected a ';' in Line %d\n", Line);

  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  000fc	50		 push	 eax
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
  00102	e8 00 00 00 00	 call	 _printf
  00107	83 c4 08	 add	 esp, 8

; 332  : 		exit(1);

  0010a	8b f4		 mov	 esi, esp
  0010c	6a 01		 push	 1
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00114	3b f4		 cmp	 esi, esp
  00116	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN5@binexpr:

; 333  : 	}
; 334  : 	right = binexpr();

  0011b	e8 00 00 00 00	 call	 _binexpr
  00120	89 45 ec	 mov	 DWORD PTR _right$[ebp], eax

; 335  : 	node = mkastnode(thisToken->tokenType, thisToken->intValue, thisToken->floatVal, left, right, NULL, NULL);

  00123	6a 00		 push	 0
  00125	6a 00		 push	 0
  00127	8b 45 ec	 mov	 eax, DWORD PTR _right$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d f8	 mov	 ecx, DWORD PTR _left$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 d4	 mov	 edx, DWORD PTR _thisToken$[ebp]
  00132	83 ec 08	 sub	 esp, 8
  00135	f2 0f 10 42 18	 movsd	 xmm0, QWORD PTR [edx+24]
  0013a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013f	8b 45 d4	 mov	 eax, DWORD PTR _thisToken$[ebp]
  00142	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00145	51		 push	 ecx
  00146	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00149	52		 push	 edx
  0014a	8b 45 d4	 mov	 eax, DWORD PTR _thisToken$[ebp]
  0014d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014f	51		 push	 ecx
  00150	e8 00 00 00 00	 call	 _mkastnode
  00155	83 c4 24	 add	 esp, 36			; 00000024H
  00158	89 45 e0	 mov	 DWORD PTR _node$[ebp], eax

; 336  : 	return node;

  0015b	8b 45 e0	 mov	 eax, DWORD PTR _node$[ebp]
$LN1@binexpr:

; 337  : }

  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx
  00161	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00167	3b ec		 cmp	 ebp, esp
  00169	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016e	8b e5		 mov	 esp, ebp
  00170	5d		 pop	 ebp
  00171	c3		 ret	 0
_binexpr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_ident
_TEXT	SEGMENT
_initNode$ = -8						; size = 4
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_right$ = 32						; size = 4
_otherData$ = 36					; size = 4
_varName$ = 40						; size = 4
_data$ = 44						; size = 4
_mkastnode_ident PROC					; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 193  : 	struct AST_Node* initNode = malloc(sizeof(struct AST_Node));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 28		 push	 40			; 00000028H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initNode$[ebp], eax

; 194  : 	initNode->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 195  : 	initNode->intVal = intVal;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _intVal$[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx
  00050	8b 55 10	 mov	 edx, DWORD PTR _intVal$[ebp+4]
  00053	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 196  : 	initNode->floatVal = floatVal;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00059	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _floatVal$[ebp]
  0005e	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 197  : 	initNode->left = left;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00066	8b 4d 1c	 mov	 ecx, DWORD PTR _left$[ebp]
  00069	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 198  : 	initNode->right = right;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0006f	8b 4d 20	 mov	 ecx, DWORD PTR _right$[ebp]
  00072	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 199  : 	initNode->otherData = otherData;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00078	8b 4d 24	 mov	 ecx, DWORD PTR _otherData$[ebp]
  0007b	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 200  : 	initNode->varName = varName;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00081	8b 4d 28	 mov	 ecx, DWORD PTR _varName$[ebp]
  00084	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 201  : 	initNode->data = data;

  00087	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0008a	8b 4d 2c	 mov	 ecx, DWORD PTR _data$[ebp]
  0008d	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 202  : 	return initNode;

  00090	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]

; 203  : }

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_mkastnode_ident ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_left
_TEXT	SEGMENT
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_otherData$ = 32					; size = 4
_data$ = 36						; size = 4
_mkastnode_left PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 187  : 	return(mkastnode(tokenType, intVal, floatVal, left, NULL, otherData, data));

  00028	8b 45 24	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 20	 mov	 ecx, DWORD PTR _otherData$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	8b 55 1c	 mov	 edx, DWORD PTR _left$[ebp]
  00035	52		 push	 edx
  00036	83 ec 08	 sub	 esp, 8
  00039	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _floatVal$[ebp]
  0003e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00043	8b 45 10	 mov	 eax, DWORD PTR _intVal$[ebp+4]
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _intVal$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _tokenType$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _mkastnode
  00054	83 c4 24	 add	 esp, 36			; 00000024H

; 188  : 
; 189  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_mkastnode_left ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_const
_TEXT	SEGMENT
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_otherData$ = 28					; size = 4
_data$ = 32						; size = 4
_mkastnode_const PROC					; COMDAT

; 181  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 182  : 	return(mkastnode(tokenType, intVal, floatVal, NULL, NULL, otherData, data));

  00028	8b 45 20	 mov	 eax, DWORD PTR _data$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 1c	 mov	 ecx, DWORD PTR _otherData$[ebp]
  0002f	51		 push	 ecx
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	83 ec 08	 sub	 esp, 8
  00037	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _floatVal$[ebp]
  0003c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00041	8b 55 10	 mov	 edx, DWORD PTR _intVal$[ebp+4]
  00044	52		 push	 edx
  00045	8b 45 0c	 mov	 eax, DWORD PTR _intVal$[ebp]
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _mkastnode
  00052	83 c4 24	 add	 esp, 36			; 00000024H

; 183  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_mkastnode_const ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode
_TEXT	SEGMENT
_initNode$ = -8						; size = 4
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_right$ = 32						; size = 4
_otherData$ = 36					; size = 4
_data$ = 40						; size = 4
_mkastnode PROC						; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __B5AFADD0_genAST@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 167  : 	struct AST_Node* initNode = malloc(sizeof(struct AST_Node));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 28		 push	 40			; 00000028H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initNode$[ebp], eax

; 168  : 	initNode->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 169  : 	initNode->intVal = intVal;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _intVal$[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx
  00050	8b 55 10	 mov	 edx, DWORD PTR _intVal$[ebp+4]
  00053	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 170  : 	initNode->floatVal = floatVal;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00059	f2 0f 10 45 14	 movsd	 xmm0, QWORD PTR _floatVal$[ebp]
  0005e	f2 0f 11 40 08	 movsd	 QWORD PTR [eax+8], xmm0

; 171  : 	initNode->left = left;

  00063	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00066	8b 4d 1c	 mov	 ecx, DWORD PTR _left$[ebp]
  00069	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 172  : 	initNode->right = right;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0006f	8b 4d 20	 mov	 ecx, DWORD PTR _right$[ebp]
  00072	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 173  : 	initNode->otherData = otherData;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00078	8b 4d 24	 mov	 ecx, DWORD PTR _otherData$[ebp]
  0007b	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 174  : 	initNode->varName = NULL;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  00081	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 175  : 	initNode->data = data;

  00088	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]
  0008b	8b 4d 28	 mov	 ecx, DWORD PTR _data$[ebp]
  0008e	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 176  : 	return initNode;

  00091	8b 45 f8	 mov	 eax, DWORD PTR _initNode$[ebp]

; 177  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0009d	3b ec		 cmp	 ebp, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_mkastnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _new_DATA_STRUCT
_TEXT	SEGMENT
_init$ = -8						; size = 4
_strVal$ = 8						; size = 4
_boolVal$ = 12						; size = 4
_doubleVal$ = 16					; size = 4
_intVal$ = 20						; size = 8
_charVal$ = 28						; size = 4
_dataType$ = 32						; size = 4
_minusVal$ = 36						; size = 4
_new_DATA_STRUCT PROC					; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 29   : 	struct DATA_STRUCT* init = malloc(sizeof(struct DATA_STRUCT));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 1c		 push	 28			; 0000001cH
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _init$[ebp], eax

; 30   : 	init->strVal = strVal;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _strVal$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 31   : 	init->boolVal = boolVal;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _boolVal$[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 32   : 	init->doubleVal = doubleVal;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _doubleVal$[ebp]
  00056	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 33   : 	init->intVal = intVal;

  00059	8b 45 14	 mov	 eax, DWORD PTR _intVal$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _init$[ebp]
  0005f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 34   : 	init->charVal = charVal;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00065	8b 4d 1c	 mov	 ecx, DWORD PTR _charVal$[ebp]
  00068	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 35   : 	init->dataType = dataType;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  0006e	8b 4d 20	 mov	 ecx, DWORD PTR _dataType$[ebp]
  00071	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 36   : 	init->minusVal = minusVal;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00077	8b 4d 24	 mov	 ecx, DWORD PTR _minusVal$[ebp]
  0007a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 37   : 	return init;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]

; 38   : };

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_new_DATA_STRUCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	8b f4		 mov	 esi, esp
  0003a	6a 01		 push	 1
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __vfprintf_l
  00052	83 c4 10	 add	 esp, 16			; 00000010H
  00055	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  00058	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	51		 push	 ecx
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 644  :     }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1850469A_corecrt_stdio_config@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
