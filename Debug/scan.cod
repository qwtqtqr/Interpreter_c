; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_05OODBEKIG@while@				; `string'
PUBLIC	??_C@_03MEPDGFMA@var@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8478A1A4_tokens@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__8DC84CAD_corecrt_wtime@h DB 01H
__CF01F9AA_time@h DB 01H
__56B56370_scan@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var@
CONST	SEGMENT
??_C@_03MEPDGFMA@var@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while@
CONST	SEGMENT
??_C@_05OODBEKIG@while@ DB 'while', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_next
PUBLIC	_putback
PUBLIC	_skip
PUBLIC	_scan_tokens
PUBLIC	_chrpos
PUBLIC	_scanIntAndFloat
PUBLIC	_scanident
PUBLIC	_createFinalString
PUBLIC	_createNewString
PUBLIC	_scanChars
PUBLIC	_scan_curToken
PUBLIC	_skip_comments
PUBLIC	_putBack_curToken
PUBLIC	_keyword
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@ ; `string'
PUBLIC	??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@ ; `string'
PUBLIC	??_C@_0L@FPFMPDDA@0123456789@			; `string'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	__real@4024000000000000
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fgetc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_newLinkedList:PROC
EXTRN	_LinkedList_add_end:PROC
EXTRN	_LinkedList_size:PROC
EXTRN	_LinkedList_getNode:PROC
EXTRN	_strchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_pow:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	__ftol2:PROC
EXTRN	__ltod3:PROC
EXTRN	_Text:BYTE
EXTRN	_Line:DWORD
EXTRN	_Putback:DWORD
EXTRN	_Infile:DWORD
EXTRN	_currentToken:DWORD
EXTRN	_globl_putback_token:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FPFMPDDA@0123456789@
CONST	SEGMENT
??_C@_0L@FPFMPDDA@0123456789@ DB '0123456789', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
CONST	SEGMENT
??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@ DB '[ER'
	DB	'ROR] unknown token in Line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@
CONST	SEGMENT
??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@ DB '['
	DB	'SYNTAX ERROR]  a ''%c'' is missing (Line %d)', 0aH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@
CONST	SEGMENT
??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@ DB 'identifier t'
	DB	'oo long line %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_multicharTokens DD FLAT:??_C@_05IJDJACGD@print@
	DD	07H
	DD	FLAT:??_C@_02HEBPBKGD@if@
	DD	08H
	DD	FLAT:??_C@_05OODBEKIG@while@
	DD	0eH
	DD	FLAT:??_C@_03MEPDGFMA@var@
	DD	014H
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	015H
	DD	FLAT:??_C@_04LOAJBDKD@true@
	DD	01fH
	DD	FLAT:??_C@_05LAPONLG@false@
	DD	020H
_singleCharTokens DD 02bH
	DD	00H
	DD	02dH
	DD	01H
	DD	02aH
	DD	02H
	DD	02fH
	DD	03H
	DD	05eH
	DD	04H
	DD	03bH
	DD	06H
	DD	028H
	DD	09H
	DD	029H
	DD	0aH
	DD	07bH
	DD	0bH
	DD	07dH
	DD	0cH
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_cmp_operators
_TEXT	SEGMENT
tv64 = -208						; size = 4
_c$ = -8						; size = 4
_c_$ = 8						; size = 4
_scan_cmp_operators PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  : 	int c = c_;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c_$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 123  : 	switch (c)

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00031	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00037	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0003d	83 e9 21	 sub	 ecx, 33			; 00000021H
  00040	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00046	83 bd 30 ff ff
	ff 5b		 cmp	 DWORD PTR tv64[ebp], 91	; 0000005bH
  0004d	0f 87 49 01 00
	00		 ja	 $LN2@scan_cmp_o
  00053	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00059	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN17@scan_cmp_o[edx]
  00060	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@scan_cmp_o[eax*4]
$LN4@scan_cmp_o:

; 124  : 	{
; 125  : 	case '=':
; 126  : 		c = next();

  00067	e8 00 00 00 00	 call	 _next
  0006c	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 127  : 		if (c == '=')

  0006f	83 7d f8 3d	 cmp	 DWORD PTR _c$[ebp], 61	; 0000003dH
  00073	75 0a		 jne	 SHORT $LN5@scan_cmp_o

; 128  : 		{
; 129  : 			return TT_EQUALS_CMP;

  00075	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0007a	e9 20 01 00 00	 jmp	 $LN16@scan_cmp_o
$LN5@scan_cmp_o:

; 130  : 		}
; 131  : 
; 132  : 		putback(c);

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _putback
  00088	83 c4 04	 add	 esp, 4

; 133  : 		return TT_EQUALS;

  0008b	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  00090	e9 0a 01 00 00	 jmp	 $LN16@scan_cmp_o
$LN6@scan_cmp_o:

; 134  : 
; 135  : 	case '!':
; 136  : 		c = next();

  00095	e8 00 00 00 00	 call	 _next
  0009a	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 137  : 		if (c == '=')

  0009d	83 7d f8 3d	 cmp	 DWORD PTR _c$[ebp], 61	; 0000003dH
  000a1	75 0a		 jne	 SHORT $LN7@scan_cmp_o

; 138  : 		{
; 139  : 			return TT_NOT_EQUALS;

  000a3	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH
  000a8	e9 f2 00 00 00	 jmp	 $LN16@scan_cmp_o
$LN7@scan_cmp_o:

; 140  : 		}
; 141  : 		printf("[ERROR] unknown token in Line %d\n", Line);

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
  000b8	e8 00 00 00 00	 call	 _printf
  000bd	83 c4 08	 add	 esp, 8

; 142  : 		exit(1);

  000c0	8b f4		 mov	 esi, esp
  000c2	6a 01		 push	 1
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN8@scan_cmp_o:

; 143  : 
; 144  : 	case '>':
; 145  : 		c = next();

  000d1	e8 00 00 00 00	 call	 _next
  000d6	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 146  : 		if (c == '=')

  000d9	83 7d f8 3d	 cmp	 DWORD PTR _c$[ebp], 61	; 0000003dH
  000dd	75 0a		 jne	 SHORT $LN9@scan_cmp_o

; 147  : 		{
; 148  : 			return TT_GREATER_EQUALS;

  000df	b8 1d 00 00 00	 mov	 eax, 29			; 0000001dH
  000e4	e9 b6 00 00 00	 jmp	 $LN16@scan_cmp_o
$LN9@scan_cmp_o:

; 149  : 		}
; 150  : 		putback(c);

  000e9	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _putback
  000f2	83 c4 04	 add	 esp, 4

; 151  : 		return TT_GREATER;

  000f5	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH
  000fa	e9 a0 00 00 00	 jmp	 $LN16@scan_cmp_o
$LN10@scan_cmp_o:

; 152  : 
; 153  : 	case '<':
; 154  : 		c = next();

  000ff	e8 00 00 00 00	 call	 _next
  00104	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 155  : 		if (c == '=')

  00107	83 7d f8 3d	 cmp	 DWORD PTR _c$[ebp], 61	; 0000003dH
  0010b	75 0a		 jne	 SHORT $LN11@scan_cmp_o

; 156  : 		{
; 157  : 			return TT_SMALLER_EQUALS;

  0010d	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  00112	e9 88 00 00 00	 jmp	 $LN16@scan_cmp_o
$LN11@scan_cmp_o:

; 158  : 		}
; 159  : 		putback(c);

  00117	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _putback
  00120	83 c4 04	 add	 esp, 4

; 160  : 		return TT_SMALLER;

  00123	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  00128	eb 75		 jmp	 SHORT $LN16@scan_cmp_o
$LN12@scan_cmp_o:

; 161  : 
; 162  : 	case '&':
; 163  : 		c = next();

  0012a	e8 00 00 00 00	 call	 _next
  0012f	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 164  : 		if (c == '&')

  00132	83 7d f8 26	 cmp	 DWORD PTR _c$[ebp], 38	; 00000026H
  00136	75 07		 jne	 SHORT $LN13@scan_cmp_o

; 165  : 		{
; 166  : 			return TT_AND;

  00138	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  0013d	eb 60		 jmp	 SHORT $LN16@scan_cmp_o
$LN13@scan_cmp_o:

; 167  : 		}
; 168  : 		printf("[ERROR] unknown token in Line %d\n", Line);

  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00144	50		 push	 eax
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
  0014a	e8 00 00 00 00	 call	 _printf
  0014f	83 c4 08	 add	 esp, 8

; 169  : 		exit(1);

  00152	8b f4		 mov	 esi, esp
  00154	6a 01		 push	 1
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0015c	3b f4		 cmp	 esi, esp
  0015e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@scan_cmp_o:

; 170  : 
; 171  : 	case '|':
; 172  : 		c = next();

  00163	e8 00 00 00 00	 call	 _next
  00168	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 173  : 		if (c == '|')

  0016b	83 7d f8 7c	 cmp	 DWORD PTR _c$[ebp], 124	; 0000007cH
  0016f	75 07		 jne	 SHORT $LN15@scan_cmp_o

; 174  : 		{
; 175  : 			return TT_OR;

  00171	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00176	eb 27		 jmp	 SHORT $LN16@scan_cmp_o
$LN15@scan_cmp_o:

; 176  : 		}
; 177  : 		printf("[ERROR] unknown token in Line %d\n", Line);

  00178	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0017d	50		 push	 eax
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IFAJDNJA@?$FLERROR?$FN?5unknown?5token?5in?5Line?5?$CF@
  00183	e8 00 00 00 00	 call	 _printf
  00188	83 c4 08	 add	 esp, 8

; 178  : 		exit(1);

  0018b	8b f4		 mov	 esi, esp
  0018d	6a 01		 push	 1
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00195	3b f4		 cmp	 esi, esp
  00197	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@scan_cmp_o:

; 179  : 
; 180  : 	}
; 181  : 	return -1;

  0019c	83 c8 ff	 or	 eax, -1
$LN16@scan_cmp_o:

; 182  : }

  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  001a8	3b ec		 cmp	 ebp, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
  001b3	90		 npad	 1
$LN18@scan_cmp_o:
  001b4	00 00 00 00	 DD	 $LN6@scan_cmp_o
  001b8	00 00 00 00	 DD	 $LN12@scan_cmp_o
  001bc	00 00 00 00	 DD	 $LN10@scan_cmp_o
  001c0	00 00 00 00	 DD	 $LN4@scan_cmp_o
  001c4	00 00 00 00	 DD	 $LN8@scan_cmp_o
  001c8	00 00 00 00	 DD	 $LN14@scan_cmp_o
  001cc	00 00 00 00	 DD	 $LN2@scan_cmp_o
$LN17@scan_cmp_o:
  001d0	00		 DB	 0
  001d1	06		 DB	 6
  001d2	06		 DB	 6
  001d3	06		 DB	 6
  001d4	06		 DB	 6
  001d5	01		 DB	 1
  001d6	06		 DB	 6
  001d7	06		 DB	 6
  001d8	06		 DB	 6
  001d9	06		 DB	 6
  001da	06		 DB	 6
  001db	06		 DB	 6
  001dc	06		 DB	 6
  001dd	06		 DB	 6
  001de	06		 DB	 6
  001df	06		 DB	 6
  001e0	06		 DB	 6
  001e1	06		 DB	 6
  001e2	06		 DB	 6
  001e3	06		 DB	 6
  001e4	06		 DB	 6
  001e5	06		 DB	 6
  001e6	06		 DB	 6
  001e7	06		 DB	 6
  001e8	06		 DB	 6
  001e9	06		 DB	 6
  001ea	06		 DB	 6
  001eb	02		 DB	 2
  001ec	03		 DB	 3
  001ed	04		 DB	 4
  001ee	06		 DB	 6
  001ef	06		 DB	 6
  001f0	06		 DB	 6
  001f1	06		 DB	 6
  001f2	06		 DB	 6
  001f3	06		 DB	 6
  001f4	06		 DB	 6
  001f5	06		 DB	 6
  001f6	06		 DB	 6
  001f7	06		 DB	 6
  001f8	06		 DB	 6
  001f9	06		 DB	 6
  001fa	06		 DB	 6
  001fb	06		 DB	 6
  001fc	06		 DB	 6
  001fd	06		 DB	 6
  001fe	06		 DB	 6
  001ff	06		 DB	 6
  00200	06		 DB	 6
  00201	06		 DB	 6
  00202	06		 DB	 6
  00203	06		 DB	 6
  00204	06		 DB	 6
  00205	06		 DB	 6
  00206	06		 DB	 6
  00207	06		 DB	 6
  00208	06		 DB	 6
  00209	06		 DB	 6
  0020a	06		 DB	 6
  0020b	06		 DB	 6
  0020c	06		 DB	 6
  0020d	06		 DB	 6
  0020e	06		 DB	 6
  0020f	06		 DB	 6
  00210	06		 DB	 6
  00211	06		 DB	 6
  00212	06		 DB	 6
  00213	06		 DB	 6
  00214	06		 DB	 6
  00215	06		 DB	 6
  00216	06		 DB	 6
  00217	06		 DB	 6
  00218	06		 DB	 6
  00219	06		 DB	 6
  0021a	06		 DB	 6
  0021b	06		 DB	 6
  0021c	06		 DB	 6
  0021d	06		 DB	 6
  0021e	06		 DB	 6
  0021f	06		 DB	 6
  00220	06		 DB	 6
  00221	06		 DB	 6
  00222	06		 DB	 6
  00223	06		 DB	 6
  00224	06		 DB	 6
  00225	06		 DB	 6
  00226	06		 DB	 6
  00227	06		 DB	 6
  00228	06		 DB	 6
  00229	06		 DB	 6
  0022a	06		 DB	 6
  0022b	05		 DB	 5
_scan_cmp_operators ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _keyword
_TEXT	SEGMENT
_retVal_ident$ = -56					; size = 8
_retVal$1 = -40						; size = 8
_curToken$2 = -24					; size = 8
_i$3 = -8						; size = 4
_s$ = 8							; size = 4
_keyword PROC						; COMDAT

; 42   : struct keyword_returnVal keyword(char* s) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   : 	for (size_t i = 0; i < arraySize(multicharTokens); i++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@keyword
$LN2@keyword:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@keyword:
  0003a	83 7d f8 07	 cmp	 DWORD PTR _i$3[ebp], 7
  0003e	73 42		 jae	 SHORT $LN3@keyword

; 44   : 	{
; 45   : 		struct TokenIdent curToken = multicharTokens[i];

  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00043	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _multicharTokens[eax*8]
  0004a	8b 14 c5 04 00
	00 00		 mov	 edx, DWORD PTR _multicharTokens[eax*8+4]
  00051	89 4d e8	 mov	 DWORD PTR _curToken$2[ebp], ecx
  00054	89 55 ec	 mov	 DWORD PTR _curToken$2[ebp+4], edx

; 46   : 
; 47   : 		if (!strcmp(s, curToken.tokenStr))

  00057	8b 45 e8	 mov	 eax, DWORD PTR _curToken$2[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 _strcmp
  00064	83 c4 08	 add	 esp, 8
  00067	85 c0		 test	 eax, eax
  00069	75 15		 jne	 SHORT $LN5@keyword

; 48   : 		{
; 49   : 			struct keyword_returnVal retVal = { curToken.tokenType, NULL };

  0006b	8b 45 ec	 mov	 eax, DWORD PTR _curToken$2[ebp+4]
  0006e	89 45 d8	 mov	 DWORD PTR _retVal$1[ebp], eax
  00071	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _retVal$1[ebp+4], 0

; 50   : 			return (retVal);

  00078	8b 45 d8	 mov	 eax, DWORD PTR _retVal$1[ebp]
  0007b	8b 55 dc	 mov	 edx, DWORD PTR _retVal$1[ebp+4]
  0007e	eb 15		 jmp	 SHORT $LN1@keyword
$LN5@keyword:

; 51   : 		}
; 52   : 	}

  00080	eb af		 jmp	 SHORT $LN2@keyword
$LN3@keyword:

; 53   : 	struct keyword_returnVal retVal_ident = { TT_IDENT, s };

  00082	c7 45 c8 12 00
	00 00		 mov	 DWORD PTR _retVal_ident$[ebp], 18 ; 00000012H
  00089	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0008c	89 45 cc	 mov	 DWORD PTR _retVal_ident$[ebp+4], eax

; 54   : 	return retVal_ident;

  0008f	8b 45 c8	 mov	 eax, DWORD PTR _retVal_ident$[ebp]
  00092	8b 55 cc	 mov	 edx, DWORD PTR _retVal_ident$[ebp+4]
$LN1@keyword:

; 55   : }

  00095	52		 push	 edx
  00096	8b cd		 mov	 ecx, ebp
  00098	50		 push	 eax
  00099	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@keyword
  0009f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a4	58		 pop	 eax
  000a5	5a		 pop	 edx
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000af	3b ec		 cmp	 ebp, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
  000ba	66 90		 npad	 2
$LN11@keyword:
  000bc	03 00 00 00	 DD	 3
  000c0	00 00 00 00	 DD	 $LN10@keyword
$LN10@keyword:
  000c4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000c8	08 00 00 00	 DD	 8
  000cc	00 00 00 00	 DD	 $LN7@keyword
  000d0	d8 ff ff ff	 DD	 -40			; ffffffd8H
  000d4	08 00 00 00	 DD	 8
  000d8	00 00 00 00	 DD	 $LN8@keyword
  000dc	c8 ff ff ff	 DD	 -56			; ffffffc8H
  000e0	08 00 00 00	 DD	 8
  000e4	00 00 00 00	 DD	 $LN9@keyword
$LN9@keyword:
  000e8	72		 DB	 114			; 00000072H
  000e9	65		 DB	 101			; 00000065H
  000ea	74		 DB	 116			; 00000074H
  000eb	56		 DB	 86			; 00000056H
  000ec	61		 DB	 97			; 00000061H
  000ed	6c		 DB	 108			; 0000006cH
  000ee	5f		 DB	 95			; 0000005fH
  000ef	69		 DB	 105			; 00000069H
  000f0	64		 DB	 100			; 00000064H
  000f1	65		 DB	 101			; 00000065H
  000f2	6e		 DB	 110			; 0000006eH
  000f3	74		 DB	 116			; 00000074H
  000f4	00		 DB	 0
$LN8@keyword:
  000f5	72		 DB	 114			; 00000072H
  000f6	65		 DB	 101			; 00000065H
  000f7	74		 DB	 116			; 00000074H
  000f8	56		 DB	 86			; 00000056H
  000f9	61		 DB	 97			; 00000061H
  000fa	6c		 DB	 108			; 0000006cH
  000fb	00		 DB	 0
$LN7@keyword:
  000fc	63		 DB	 99			; 00000063H
  000fd	75		 DB	 117			; 00000075H
  000fe	72		 DB	 114			; 00000072H
  000ff	54		 DB	 84			; 00000054H
  00100	6f		 DB	 111			; 0000006fH
  00101	6b		 DB	 107			; 0000006bH
  00102	65		 DB	 101			; 00000065H
  00103	6e		 DB	 110			; 0000006eH
  00104	00		 DB	 0
_keyword ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _putBack_curToken
_TEXT	SEGMENT
_token$ = 8						; size = 4
_putBack_curToken PROC					; COMDAT

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 186  : 	globl_putback_token = token;

  00028	8b 45 08	 mov	 eax, DWORD PTR _token$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR _globl_putback_token, eax

; 187  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_putBack_curToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _skip_comments
_TEXT	SEGMENT
_c$ = -8						; size = 4
_c_$ = 8						; size = 4
_skip_comments PROC					; COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 310  : 	int c = c_;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c_$[ebp]
  0002b	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 311  : 	if (c == '/')

  0002e	83 7d f8 2f	 cmp	 DWORD PTR _c$[ebp], 47	; 0000002fH
  00032	75 24		 jne	 SHORT $LN1@skip_comme

; 312  : 	{
; 313  : 		c = next();

  00034	e8 00 00 00 00	 call	 _next
  00039	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 314  : 		if (c == '/')

  0003c	83 7d f8 2f	 cmp	 DWORD PTR _c$[ebp], 47	; 0000002fH
  00040	75 16		 jne	 SHORT $LN1@skip_comme
$LN2@skip_comme:

; 315  : 		{
; 316  : 			while (c != '\n' && c != EOF)

  00042	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00046	74 10		 je	 SHORT $LN1@skip_comme
  00048	83 7d f8 ff	 cmp	 DWORD PTR _c$[ebp], -1
  0004c	74 0a		 je	 SHORT $LN1@skip_comme

; 317  : 			{
; 318  : 				c = next();

  0004e	e8 00 00 00 00	 call	 _next
  00053	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 319  : 			}

  00056	eb ea		 jmp	 SHORT $LN2@skip_comme
$LN1@skip_comme:

; 320  : 		}
; 321  : 	}
; 322  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_skip_comments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_curToken
_TEXT	SEGMENT
$T1 = -464						; size = 24
_valPtr$2 = -240					; size = 4
_val$3 = -225						; size = 1
_charT$ = -216						; size = 2
_string_final$4 = -204					; size = 4
_strList$5 = -192					; size = 4
_keyword_tt$6 = -180					; size = 4
_cur_key_ret_val$7 = -168				; size = 8
_floatValPtr$8 = -152					; size = 4
_floatVal$9 = -140					; size = 8
_intValPtr$10 = -124					; size = 4
_intVal$11 = -112					; size = 8
_numTT$12 = -96						; size = 4
_numStruct$13 = -84					; size = 24
_cmp_op$ = -52						; size = 4
_curIdent$14 = -40					; size = 8
_i$15 = -24						; size = 4
_c$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_scan_curToken PROC					; COMDAT

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 01 00
	00		 sub	 esp, 468		; 000001d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 2c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-468]
  00012	b9 75 00 00 00	 mov	 ecx, 117		; 00000075H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 328  : 
; 329  : 	if (globl_putback_token != NULL)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _globl_putback_token, 0
  00039	74 19		 je	 SHORT $LN5@scan_curTo

; 330  : 	{
; 331  : 		currentToken = globl_putback_token;

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR _globl_putback_token
  00040	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax

; 332  : 		globl_putback_token = NULL;

  00045	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _globl_putback_token, 0

; 333  : 		return;

  0004f	e9 f3 03 00 00	 jmp	 $LN18@scan_curTo
$LN5@scan_curTo:

; 334  : 	}
; 335  : 
; 336  : 	int c = skip();

  00054	e8 00 00 00 00	 call	 _skip
  00059	89 45 f4	 mov	 DWORD PTR _c$[ebp], eax

; 337  : 	skip_comments(c);

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _skip_comments
  00065	83 c4 04	 add	 esp, 4

; 338  : 
; 339  : 	if (c == EOF)

  00068	83 7d f4 ff	 cmp	 DWORD PTR _c$[ebp], -1
  0006c	75 1b		 jne	 SHORT $LN6@scan_curTo

; 340  : 	{
; 341  : 		currentToken = newToken(TT_EOF, 0, Line, NULL);

  0006e	6a 00		 push	 0
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00075	50		 push	 eax
  00076	6a 00		 push	 0
  00078	6a 00		 push	 0
  0007a	6a 11		 push	 17			; 00000011H
  0007c	e8 00 00 00 00	 call	 _newToken
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN6@scan_curTo:

; 342  : 	}
; 343  : 	for (size_t i = 0; i < arraySize(singleCharTokens); i++)

  00089	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$15[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN4@scan_curTo
$LN2@scan_curTo:
  00092	8b 45 e8	 mov	 eax, DWORD PTR _i$15[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 e8	 mov	 DWORD PTR _i$15[ebp], eax
$LN4@scan_curTo:
  0009b	83 7d e8 0a	 cmp	 DWORD PTR _i$15[ebp], 10 ; 0000000aH
  0009f	73 4d		 jae	 SHORT $LN3@scan_curTo

; 344  : 	{
; 345  : 		struct TokenIdent curIdent = singleCharTokens[i];

  000a1	8b 45 e8	 mov	 eax, DWORD PTR _i$15[ebp]
  000a4	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _singleCharTokens[eax*8]
  000ab	8b 14 c5 04 00
	00 00		 mov	 edx, DWORD PTR _singleCharTokens[eax*8+4]
  000b2	89 4d d8	 mov	 DWORD PTR _curIdent$14[ebp], ecx
  000b5	89 55 dc	 mov	 DWORD PTR _curIdent$14[ebp+4], edx

; 346  : 		if (curIdent.tokenStr == c)

  000b8	8b 45 d8	 mov	 eax, DWORD PTR _curIdent$14[ebp]
  000bb	3b 45 f4	 cmp	 eax, DWORD PTR _c$[ebp]
  000be	75 2c		 jne	 SHORT $LN7@scan_curTo

; 347  : 		{
; 348  : 			currentToken = newToken(curIdent.tokenType, 0, Line, NULL);

  000c0	6a 00		 push	 0
  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  000c7	50		 push	 eax
  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	8b 4d dc	 mov	 ecx, DWORD PTR _curIdent$14[ebp+4]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _newToken
  000d5	83 c4 14	 add	 esp, 20			; 00000014H
  000d8	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax

; 349  : 			putback(' ');

  000dd	6a 20		 push	 32			; 00000020H
  000df	e8 00 00 00 00	 call	 _putback
  000e4	83 c4 04	 add	 esp, 4

; 350  : 			return;

  000e7	e9 5b 03 00 00	 jmp	 $LN18@scan_curTo
$LN7@scan_curTo:

; 351  : 		}
; 352  : 	}

  000ec	eb a4		 jmp	 SHORT $LN2@scan_curTo
$LN3@scan_curTo:

; 353  : 
; 354  : 	int cmp_op = scan_cmp_operators(c);

  000ee	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 _scan_cmp_operators
  000f7	83 c4 04	 add	 esp, 4
  000fa	89 45 cc	 mov	 DWORD PTR _cmp_op$[ebp], eax

; 355  : 	if (cmp_op != -1)

  000fd	83 7d cc ff	 cmp	 DWORD PTR _cmp_op$[ebp], -1
  00101	74 22		 je	 SHORT $LN8@scan_curTo

; 356  : 	{
; 357  : 		currentToken = newToken(cmp_op, 0, Line, NULL);

  00103	6a 00		 push	 0
  00105	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0010a	50		 push	 eax
  0010b	6a 00		 push	 0
  0010d	6a 00		 push	 0
  0010f	8b 4d cc	 mov	 ecx, DWORD PTR _cmp_op$[ebp]
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 _newToken
  00118	83 c4 14	 add	 esp, 20			; 00000014H
  0011b	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax

; 358  : 		return;

  00120	e9 22 03 00 00	 jmp	 $LN18@scan_curTo
$LN8@scan_curTo:

; 359  : 
; 360  : 	}
; 361  : 
; 362  : 	if (isdigit(c))

  00125	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _isdigit
  0012e	83 c4 04	 add	 esp, 4
  00131	85 c0		 test	 eax, eax
  00133	0f 84 33 01 00
	00		 je	 $LN9@scan_curTo

; 363  : 	{
; 364  : 		struct NumericVal numStruct = scanIntAndFloat(c);

  00139	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  0013c	50		 push	 eax
  0013d	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _scanIntAndFloat
  00149	83 c4 08	 add	 esp, 8
  0014c	8b 10		 mov	 edx, DWORD PTR [eax]
  0014e	89 55 ac	 mov	 DWORD PTR _numStruct$13[ebp], edx
  00151	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00154	89 4d b0	 mov	 DWORD PTR _numStruct$13[ebp+4], ecx
  00157	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0015a	89 55 b4	 mov	 DWORD PTR _numStruct$13[ebp+8], edx
  0015d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00160	89 4d b8	 mov	 DWORD PTR _numStruct$13[ebp+12], ecx
  00163	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00166	89 55 bc	 mov	 DWORD PTR _numStruct$13[ebp+16], edx
  00169	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0016c	89 45 c0	 mov	 DWORD PTR _numStruct$13[ebp+20], eax

; 365  : 		int numTT = numStruct.tokenType;

  0016f	8b 45 bc	 mov	 eax, DWORD PTR _numStruct$13[ebp+16]
  00172	89 45 a0	 mov	 DWORD PTR _numTT$12[ebp], eax

; 366  : 
; 367  : 		if (numTT == TT_INT)

  00175	83 7d a0 05	 cmp	 DWORD PTR _numTT$12[ebp], 5
  00179	75 69		 jne	 SHORT $LN11@scan_curTo

; 368  : 		{
; 369  : 			INT_VAL intVal = numStruct.intVal;

  0017b	8b 45 ac	 mov	 eax, DWORD PTR _numStruct$13[ebp]
  0017e	89 45 90	 mov	 DWORD PTR _intVal$11[ebp], eax
  00181	8b 4d b0	 mov	 ecx, DWORD PTR _numStruct$13[ebp+4]
  00184	89 4d 94	 mov	 DWORD PTR _intVal$11[ebp+4], ecx

; 370  : 			long long* intValPtr = malloc(sizeof(long long));

  00187	8b f4		 mov	 esi, esp
  00189	6a 08		 push	 8
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00191	83 c4 04	 add	 esp, 4
  00194	3b f4		 cmp	 esi, esp
  00196	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019b	89 45 84	 mov	 DWORD PTR _intValPtr$10[ebp], eax

; 371  : 			*intValPtr = intVal;

  0019e	8b 45 84	 mov	 eax, DWORD PTR _intValPtr$10[ebp]
  001a1	8b 4d 90	 mov	 ecx, DWORD PTR _intVal$11[ebp]
  001a4	89 08		 mov	 DWORD PTR [eax], ecx
  001a6	8b 55 94	 mov	 edx, DWORD PTR _intVal$11[ebp+4]
  001a9	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 372  : 
; 373  : 			currentToken = newToken(TT_INT, intVal, Line, new_DATA_STRUCT(NULL, NULL, NULL, intValPtr, NULL, DT_INT, 1));

  001ac	6a 01		 push	 1
  001ae	6a 00		 push	 0
  001b0	6a 00		 push	 0
  001b2	8b 45 84	 mov	 eax, DWORD PTR _intValPtr$10[ebp]
  001b5	99		 cdq
  001b6	52		 push	 edx
  001b7	50		 push	 eax
  001b8	6a 00		 push	 0
  001ba	6a 00		 push	 0
  001bc	6a 00		 push	 0
  001be	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  001c3	83 c4 20	 add	 esp, 32			; 00000020H
  001c6	50		 push	 eax
  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  001cc	50		 push	 eax
  001cd	8b 4d 94	 mov	 ecx, DWORD PTR _intVal$11[ebp+4]
  001d0	51		 push	 ecx
  001d1	8b 55 90	 mov	 edx, DWORD PTR _intVal$11[ebp]
  001d4	52		 push	 edx
  001d5	6a 05		 push	 5
  001d7	e8 00 00 00 00	 call	 _newToken
  001dc	83 c4 14	 add	 esp, 20			; 00000014H
  001df	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN11@scan_curTo:

; 374  : 		}
; 375  : 		if (numTT == TT_FLOAT)

  001e4	83 7d a0 10	 cmp	 DWORD PTR _numTT$12[ebp], 16 ; 00000010H
  001e8	75 7d		 jne	 SHORT $LN12@scan_curTo

; 376  : 		{
; 377  : 			double floatVal = numStruct.floatVal;

  001ea	f2 0f 10 45 b4	 movsd	 xmm0, QWORD PTR _numStruct$13[ebp+8]
  001ef	f2 0f 11 85 74
	ff ff ff	 movsd	 QWORD PTR _floatVal$9[ebp], xmm0

; 378  : 			long double* floatValPtr = malloc(sizeof(long double));

  001f7	8b f4		 mov	 esi, esp
  001f9	6a 08		 push	 8
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00201	83 c4 04	 add	 esp, 4
  00204	3b f4		 cmp	 esi, esp
  00206	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0020b	89 85 68 ff ff
	ff		 mov	 DWORD PTR _floatValPtr$8[ebp], eax

; 379  : 			*floatValPtr = floatVal;

  00211	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _floatValPtr$8[ebp]
  00217	f2 0f 10 85 74
	ff ff ff	 movsd	 xmm0, QWORD PTR _floatVal$9[ebp]
  0021f	f2 0f 11 00	 movsd	 QWORD PTR [eax], xmm0

; 380  : 			currentToken = newToken_float(TT_FLOAT, floatVal, Line, new_DATA_STRUCT(NULL, NULL, floatValPtr, NULL, NULL, DT_FLOAT, 1));

  00223	6a 01		 push	 1
  00225	6a 02		 push	 2
  00227	6a 00		 push	 0
  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _floatValPtr$8[ebp]
  00233	50		 push	 eax
  00234	6a 00		 push	 0
  00236	6a 00		 push	 0
  00238	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  0023d	83 c4 20	 add	 esp, 32			; 00000020H
  00240	50		 push	 eax
  00241	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Line
  00247	51		 push	 ecx
  00248	83 ec 08	 sub	 esp, 8
  0024b	f2 0f 10 85 74
	ff ff ff	 movsd	 xmm0, QWORD PTR _floatVal$9[ebp]
  00253	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00258	6a 10		 push	 16			; 00000010H
  0025a	e8 00 00 00 00	 call	 _newToken_float
  0025f	83 c4 14	 add	 esp, 20			; 00000014H
  00262	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN12@scan_curTo:

; 381  : 		}
; 382  : 	}

  00267	e9 aa 00 00 00	 jmp	 $LN16@scan_curTo
$LN9@scan_curTo:

; 383  : 
; 384  : 	else if (isalpha(c) || c == '_')

  0026c	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 _isalpha
  00275	83 c4 04	 add	 esp, 4
  00278	85 c0		 test	 eax, eax
  0027a	75 0a		 jne	 SHORT $LN14@scan_curTo
  0027c	83 7d f4 5f	 cmp	 DWORD PTR _c$[ebp], 95	; 0000005fH
  00280	0f 85 90 00 00
	00		 jne	 $LN16@scan_curTo
$LN14@scan_curTo:

; 385  : 	{
; 386  : 
; 387  : 		scanident(c, Text, TEXTLEN);

  00286	68 00 02 00 00	 push	 512			; 00000200H
  0028b	68 00 00 00 00	 push	 OFFSET _Text
  00290	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 _scanident
  00299	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  : 		struct keyword_returnVal cur_key_ret_val = keyword(Text);

  0029c	68 00 00 00 00	 push	 OFFSET _Text
  002a1	e8 00 00 00 00	 call	 _keyword
  002a6	83 c4 04	 add	 esp, 4
  002a9	89 85 58 ff ff
	ff		 mov	 DWORD PTR _cur_key_ret_val$7[ebp], eax
  002af	89 95 5c ff ff
	ff		 mov	 DWORD PTR _cur_key_ret_val$7[ebp+4], edx

; 389  : 		int keyword_tt = cur_key_ret_val.TokenType;

  002b5	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _cur_key_ret_val$7[ebp]
  002bb	89 85 4c ff ff
	ff		 mov	 DWORD PTR _keyword_tt$6[ebp], eax

; 390  : 		if (keyword_tt != TT_IDENT)

  002c1	83 bd 4c ff ff
	ff 12		 cmp	 DWORD PTR _keyword_tt$6[ebp], 18 ; 00000012H
  002c8	74 20		 je	 SHORT $LN15@scan_curTo

; 391  : 		{
; 392  : 			currentToken = newToken(keyword_tt, 0, Line, NULL);

  002ca	6a 00		 push	 0
  002cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  002d1	50		 push	 eax
  002d2	6a 00		 push	 0
  002d4	6a 00		 push	 0
  002d6	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _keyword_tt$6[ebp]
  002dc	51		 push	 ecx
  002dd	e8 00 00 00 00	 call	 _newToken
  002e2	83 c4 14	 add	 esp, 20			; 00000014H
  002e5	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN15@scan_curTo:

; 393  : 		}
; 394  : 		if (keyword_tt == TT_IDENT)

  002ea	83 bd 4c ff ff
	ff 12		 cmp	 DWORD PTR _keyword_tt$6[ebp], 18 ; 00000012H
  002f1	75 23		 jne	 SHORT $LN16@scan_curTo

; 395  : 		{
; 396  : 			currentToken = newToken_identToken(TT_IDENT, Line, cur_key_ret_val.ident_name, 0, NULL);

  002f3	6a 00		 push	 0
  002f5	6a 00		 push	 0
  002f7	6a 00		 push	 0
  002f9	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _cur_key_ret_val$7[ebp+4]
  002ff	50		 push	 eax
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Line
  00306	51		 push	 ecx
  00307	6a 12		 push	 18			; 00000012H
  00309	e8 00 00 00 00	 call	 _newToken_identToken
  0030e	83 c4 18	 add	 esp, 24			; 00000018H
  00311	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN16@scan_curTo:

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	if (c == '"')

  00316	83 7d f4 22	 cmp	 DWORD PTR _c$[ebp], 34	; 00000022H
  0031a	0f 85 8b 00 00
	00		 jne	 $LN17@scan_curTo

; 401  : 	{
; 402  : 		LinkedList* strList = newLinkedList();

  00320	e8 00 00 00 00	 call	 _newLinkedList
  00325	89 85 40 ff ff
	ff		 mov	 DWORD PTR _strList$5[ebp], eax

; 403  : 		createNewString(c, strList);

  0032b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _strList$5[ebp]
  00331	50		 push	 eax
  00332	8b 4d f4	 mov	 ecx, DWORD PTR _c$[ebp]
  00335	51		 push	 ecx
  00336	e8 00 00 00 00	 call	 _createNewString
  0033b	83 c4 08	 add	 esp, 8

; 404  : 		char* string_final = createFinalString(strList);

  0033e	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _strList$5[ebp]
  00344	50		 push	 eax
  00345	e8 00 00 00 00	 call	 _createFinalString
  0034a	83 c4 04	 add	 esp, 4
  0034d	89 85 34 ff ff
	ff		 mov	 DWORD PTR _string_final$4[ebp], eax

; 405  : 		currentToken = newToken_str(TT_STRING, 0, Line, string_final, new_DATA_STRUCT(string_final, NULL, NULL, NULL, NULL, DT_STRING, 1));

  00353	6a 01		 push	 1
  00355	6a 04		 push	 4
  00357	6a 00		 push	 0
  00359	6a 00		 push	 0
  0035b	6a 00		 push	 0
  0035d	6a 00		 push	 0
  0035f	6a 00		 push	 0
  00361	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR _string_final$4[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  0036d	83 c4 20	 add	 esp, 32			; 00000020H
  00370	50		 push	 eax
  00371	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR _string_final$4[ebp]
  00377	51		 push	 ecx
  00378	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Line
  0037e	52		 push	 edx
  0037f	6a 00		 push	 0
  00381	6a 00		 push	 0
  00383	6a 0d		 push	 13			; 0000000dH
  00385	e8 00 00 00 00	 call	 _newToken_str
  0038a	83 c4 18	 add	 esp, 24			; 00000018H
  0038d	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax

; 406  : 
; 407  : 		free(strList);

  00392	8b f4		 mov	 esi, esp
  00394	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _strList$5[ebp]
  0039a	50		 push	 eax
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  003a1	83 c4 04	 add	 esp, 4
  003a4	3b f4		 cmp	 esi, esp
  003a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN17@scan_curTo:

; 408  : 	}
; 409  : 
; 410  : 	char charT[] = "'";

  003ab	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01GEODFPGF@?8@
  003b1	66 89 85 28 ff
	ff ff		 mov	 WORD PTR _charT$[ebp], ax

; 411  : 	if (c == charT[0])

  003b8	b8 01 00 00 00	 mov	 eax, 1
  003bd	6b c8 00	 imul	 ecx, eax, 0
  003c0	0f be 94 0d 28
	ff ff ff	 movsx	 edx, BYTE PTR _charT$[ebp+ecx]
  003c8	39 55 f4	 cmp	 DWORD PTR _c$[ebp], edx
  003cb	75 7a		 jne	 SHORT $LN18@scan_curTo

; 412  : 	{
; 413  : 		char val = scanChars(c);

  003cd	8b 45 f4	 mov	 eax, DWORD PTR _c$[ebp]
  003d0	50		 push	 eax
  003d1	e8 00 00 00 00	 call	 _scanChars
  003d6	83 c4 04	 add	 esp, 4
  003d9	88 85 1f ff ff
	ff		 mov	 BYTE PTR _val$3[ebp], al

; 414  : 		char* valPtr = malloc(sizeof(char));

  003df	8b f4		 mov	 esi, esp
  003e1	6a 01		 push	 1
  003e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  003e9	83 c4 04	 add	 esp, 4
  003ec	3b f4		 cmp	 esi, esp
  003ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003f3	89 85 10 ff ff
	ff		 mov	 DWORD PTR _valPtr$2[ebp], eax

; 415  : 		*valPtr = val;

  003f9	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _valPtr$2[ebp]
  003ff	8a 8d 1f ff ff
	ff		 mov	 cl, BYTE PTR _val$3[ebp]
  00405	88 08		 mov	 BYTE PTR [eax], cl

; 416  : 		currentToken = newToken_str(TT_CHAR, 0, Line, val, new_DATA_STRUCT(NULL, NULL, NULL, NULL, valPtr, DT_CHAR, 1));

  00407	6a 01		 push	 1
  00409	6a 03		 push	 3
  0040b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR _valPtr$2[ebp]
  00411	50		 push	 eax
  00412	6a 00		 push	 0
  00414	6a 00		 push	 0
  00416	6a 00		 push	 0
  00418	6a 00		 push	 0
  0041a	6a 00		 push	 0
  0041c	e8 00 00 00 00	 call	 _new_DATA_STRUCT
  00421	83 c4 20	 add	 esp, 32			; 00000020H
  00424	50		 push	 eax
  00425	0f be 8d 1f ff
	ff ff		 movsx	 ecx, BYTE PTR _val$3[ebp]
  0042c	51		 push	 ecx
  0042d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Line
  00433	52		 push	 edx
  00434	6a 00		 push	 0
  00436	6a 00		 push	 0
  00438	6a 0f		 push	 15			; 0000000fH
  0043a	e8 00 00 00 00	 call	 _newToken_str
  0043f	83 c4 18	 add	 esp, 24			; 00000018H
  00442	a3 00 00 00 00	 mov	 DWORD PTR _currentToken, eax
$LN18@scan_curTo:

; 417  : 	}
; 418  : }

  00447	52		 push	 edx
  00448	8b cd		 mov	 ecx, ebp
  0044a	50		 push	 eax
  0044b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@scan_curTo
  00451	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00456	58		 pop	 eax
  00457	5a		 pop	 edx
  00458	5f		 pop	 edi
  00459	5e		 pop	 esi
  0045a	5b		 pop	 ebx
  0045b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0045e	33 cd		 xor	 ecx, ebp
  00460	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00465	81 c4 d4 01 00
	00		 add	 esp, 468		; 000001d4H
  0046b	3b ec		 cmp	 ebp, esp
  0046d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00472	8b e5		 mov	 esp, ebp
  00474	5d		 pop	 ebp
  00475	c3		 ret	 0
  00476	66 90		 npad	 2
$LN25@scan_curTo:
  00478	04 00 00 00	 DD	 4
  0047c	00 00 00 00	 DD	 $LN24@scan_curTo
$LN24@scan_curTo:
  00480	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00484	08 00 00 00	 DD	 8
  00488	00 00 00 00	 DD	 $LN20@scan_curTo
  0048c	ac ff ff ff	 DD	 -84			; ffffffacH
  00490	18 00 00 00	 DD	 24			; 00000018H
  00494	00 00 00 00	 DD	 $LN21@scan_curTo
  00498	58 ff ff ff	 DD	 -168			; ffffff58H
  0049c	08 00 00 00	 DD	 8
  004a0	00 00 00 00	 DD	 $LN22@scan_curTo
  004a4	28 ff ff ff	 DD	 -216			; ffffff28H
  004a8	02 00 00 00	 DD	 2
  004ac	00 00 00 00	 DD	 $LN23@scan_curTo
$LN23@scan_curTo:
  004b0	63		 DB	 99			; 00000063H
  004b1	68		 DB	 104			; 00000068H
  004b2	61		 DB	 97			; 00000061H
  004b3	72		 DB	 114			; 00000072H
  004b4	54		 DB	 84			; 00000054H
  004b5	00		 DB	 0
$LN22@scan_curTo:
  004b6	63		 DB	 99			; 00000063H
  004b7	75		 DB	 117			; 00000075H
  004b8	72		 DB	 114			; 00000072H
  004b9	5f		 DB	 95			; 0000005fH
  004ba	6b		 DB	 107			; 0000006bH
  004bb	65		 DB	 101			; 00000065H
  004bc	79		 DB	 121			; 00000079H
  004bd	5f		 DB	 95			; 0000005fH
  004be	72		 DB	 114			; 00000072H
  004bf	65		 DB	 101			; 00000065H
  004c0	74		 DB	 116			; 00000074H
  004c1	5f		 DB	 95			; 0000005fH
  004c2	76		 DB	 118			; 00000076H
  004c3	61		 DB	 97			; 00000061H
  004c4	6c		 DB	 108			; 0000006cH
  004c5	00		 DB	 0
$LN21@scan_curTo:
  004c6	6e		 DB	 110			; 0000006eH
  004c7	75		 DB	 117			; 00000075H
  004c8	6d		 DB	 109			; 0000006dH
  004c9	53		 DB	 83			; 00000053H
  004ca	74		 DB	 116			; 00000074H
  004cb	72		 DB	 114			; 00000072H
  004cc	75		 DB	 117			; 00000075H
  004cd	63		 DB	 99			; 00000063H
  004ce	74		 DB	 116			; 00000074H
  004cf	00		 DB	 0
$LN20@scan_curTo:
  004d0	63		 DB	 99			; 00000063H
  004d1	75		 DB	 117			; 00000075H
  004d2	72		 DB	 114			; 00000072H
  004d3	49		 DB	 73			; 00000049H
  004d4	64		 DB	 100			; 00000064H
  004d5	65		 DB	 101			; 00000065H
  004d6	6e		 DB	 110			; 0000006eH
  004d7	74		 DB	 116			; 00000074H
  004d8	00		 DB	 0
_scan_curToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanChars
_TEXT	SEGMENT
_c$ = 8							; size = 4
_scanChars PROC						; COMDAT

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 292  : 	c = next();

  00028	e8 00 00 00 00	 call	 _next
  0002d	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 293  : 	next();

  00030	e8 00 00 00 00	 call	 _next

; 294  : 	return c;

  00035	8a 45 08	 mov	 al, BYTE PTR _c$[ebp]

; 295  : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_scanChars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _createNewString
_TEXT	SEGMENT
_bufferCount$ = -44					; size = 4
_buff$ = -32						; size = 4
_curStrBuffIdx$ = -20					; size = 4
_strStartLine$ = -8					; size = 4
_c$ = 8							; size = 4
_buffList$ = 12						; size = 4
_createNewString PROC					; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   : 	int strStartLine = Line;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0002d	89 45 f8	 mov	 DWORD PTR _strStartLine$[ebp], eax

; 61   : 	c = next();

  00030	e8 00 00 00 00	 call	 _next
  00035	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 62   : 	int curStrBuffIdx = 0;

  00038	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _curStrBuffIdx$[ebp], 0

; 63   : 	char* buff = calloc(STRINGBUFF_LEN, sizeof(char));

  0003f	8b f4		 mov	 esi, esp
  00041	6a 01		 push	 1
  00043	68 00 02 00 00	 push	 512			; 00000200H
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0004e	83 c4 08	 add	 esp, 8
  00051	3b f4		 cmp	 esi, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	89 45 e0	 mov	 DWORD PTR _buff$[ebp], eax

; 64   : 	int bufferCount = 1;

  0005b	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _bufferCount$[ebp], 1
$LN2@createNewS:

; 65   : 
; 66   : 
; 67   : 	while (c != '"' && c != EOF)

  00062	83 7d 08 22	 cmp	 DWORD PTR _c$[ebp], 34	; 00000022H
  00066	74 6f		 je	 SHORT $LN3@createNewS
  00068	83 7d 08 ff	 cmp	 DWORD PTR _c$[ebp], -1
  0006c	74 69		 je	 SHORT $LN3@createNewS

; 68   : 	{
; 69   : 		buff[curStrBuffIdx] = c;

  0006e	8b 45 e0	 mov	 eax, DWORD PTR _buff$[ebp]
  00071	03 45 ec	 add	 eax, DWORD PTR _curStrBuffIdx$[ebp]
  00074	8a 4d 08	 mov	 cl, BYTE PTR _c$[ebp]
  00077	88 08		 mov	 BYTE PTR [eax], cl

; 70   : 		c = next();

  00079	e8 00 00 00 00	 call	 _next
  0007e	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 71   : 		curStrBuffIdx++;

  00081	8b 45 ec	 mov	 eax, DWORD PTR _curStrBuffIdx$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 ec	 mov	 DWORD PTR _curStrBuffIdx$[ebp], eax

; 72   : 		if (curStrBuffIdx == STRINGBUFF_LEN)

  0008a	81 7d ec 00 02
	00 00		 cmp	 DWORD PTR _curStrBuffIdx$[ebp], 512 ; 00000200H
  00091	75 42		 jne	 SHORT $LN4@createNewS

; 73   : 		{
; 74   : 			LinkedList_add_end(buffList, (char*)buff, 0, 0, NULL);

  00093	6a 00		 push	 0
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	8b 45 e0	 mov	 eax, DWORD PTR _buff$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _buffList$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _LinkedList_add_end
  000a6	83 c4 14	 add	 esp, 20			; 00000014H

; 75   : 			buff = calloc(STRINGBUFF_LEN, sizeof(char));

  000a9	8b f4		 mov	 esi, esp
  000ab	6a 01		 push	 1
  000ad	68 00 02 00 00	 push	 512			; 00000200H
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000b8	83 c4 08	 add	 esp, 8
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	89 45 e0	 mov	 DWORD PTR _buff$[ebp], eax

; 76   : 			curStrBuffIdx = 0;

  000c5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _curStrBuffIdx$[ebp], 0

; 77   : 			bufferCount++;

  000cc	8b 45 d4	 mov	 eax, DWORD PTR _bufferCount$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 d4	 mov	 DWORD PTR _bufferCount$[ebp], eax
$LN4@createNewS:

; 78   : 		}
; 79   : 	}

  000d5	eb 8b		 jmp	 SHORT $LN2@createNewS
$LN3@createNewS:

; 80   : 	LinkedList_add_end(buffList, (char*)buff, 0, 0, NULL);

  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	8b 45 e0	 mov	 eax, DWORD PTR _buff$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR _buffList$[ebp]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 _LinkedList_add_end
  000ea	83 c4 14	 add	 esp, 20			; 00000014H

; 81   : 	if (c == EOF)

  000ed	83 7d 08 ff	 cmp	 DWORD PTR _c$[ebp], -1
  000f1	75 24		 jne	 SHORT $LN6@createNewS

; 82   : 	{
; 83   : 		printf("[SYNTAX ERROR]  a '%c' is missing (Line %d)\n ", '"', strStartLine);

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _strStartLine$[ebp]
  000f6	50		 push	 eax
  000f7	6a 22		 push	 34			; 00000022H
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@PNNFFEBH@?$FLSYNTAX?5ERROR?$FN?5?5a?5?8?$CFc?8?5is?5missi@
  000fe	e8 00 00 00 00	 call	 _printf
  00103	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 		exit(1);

  00106	8b f4		 mov	 esi, esp
  00108	6a 01		 push	 1
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00110	3b f4		 cmp	 esi, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@createNewS:

; 85   : 	}
; 86   : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_createNewString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _createFinalString
_TEXT	SEGMENT
_curChar$1 = -77					; size = 1
_c$2 = -68						; size = 4
_curBuffer$3 = -56					; size = 4
_listNode$ = -44					; size = 4
_curIdx$ = -32						; size = 4
_returnString$ = -20					; size = 4
_size$ = -8						; size = 4
_strBufferList$ = 8					; size = 4
_createFinalString PROC					; COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 90   : 	size_t size = (size_t)LinkedList_size(strBufferList) * STRINGBUFF_LEN + 1;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strBufferList$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _LinkedList_size
  00031	83 c4 04	 add	 esp, 4
  00034	c1 e0 09	 shl	 eax, 9
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 f8	 mov	 DWORD PTR _size$[ebp], eax

; 91   : 	char* returnString = calloc(size, sizeof(char));

  0003d	8b f4		 mov	 esi, esp
  0003f	6a 01		 push	 1
  00041	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
  00044	50		 push	 eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  0004b	83 c4 08	 add	 esp, 8
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	89 45 ec	 mov	 DWORD PTR _returnString$[ebp], eax

; 92   : 
; 93   : 	int curIdx = 0;

  00058	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _curIdx$[ebp], 0

; 94   : 
; 95   : 	node_t* listNode = LinkedList_getNode(strBufferList, 0);

  0005f	6a 00		 push	 0
  00061	8b 45 08	 mov	 eax, DWORD PTR _strBufferList$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _LinkedList_getNode
  0006a	83 c4 08	 add	 esp, 8
  0006d	89 45 d4	 mov	 DWORD PTR _listNode$[ebp], eax
$LN2@createFina:

; 96   : 	while (listNode != NULL)

  00070	83 7d d4 00	 cmp	 DWORD PTR _listNode$[ebp], 0
  00074	74 65		 je	 SHORT $LN3@createFina

; 97   : 	{
; 98   : 		char* curBuffer = (char*)listNode->data;

  00076	8b 45 d4	 mov	 eax, DWORD PTR _listNode$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	89 4d c8	 mov	 DWORD PTR _curBuffer$3[ebp], ecx

; 99   : 		for (int c = 0; c < STRINGBUFF_LEN; c++)

  0007e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _c$2[ebp], 0
  00085	eb 09		 jmp	 SHORT $LN6@createFina
$LN4@createFina:
  00087	8b 45 bc	 mov	 eax, DWORD PTR _c$2[ebp]
  0008a	83 c0 01	 add	 eax, 1
  0008d	89 45 bc	 mov	 DWORD PTR _c$2[ebp], eax
$LN6@createFina:
  00090	81 7d bc 00 02
	00 00		 cmp	 DWORD PTR _c$2[ebp], 512 ; 00000200H
  00097	7d 37		 jge	 SHORT $LN5@createFina

; 100  : 		{
; 101  : 			char curChar = *(curBuffer + c);

  00099	8b 45 c8	 mov	 eax, DWORD PTR _curBuffer$3[ebp]
  0009c	03 45 bc	 add	 eax, DWORD PTR _c$2[ebp]
  0009f	8a 08		 mov	 cl, BYTE PTR [eax]
  000a1	88 4d b3	 mov	 BYTE PTR _curChar$1[ebp], cl

; 102  : 			returnString[curIdx] = curChar;

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _returnString$[ebp]
  000a7	03 45 e0	 add	 eax, DWORD PTR _curIdx$[ebp]
  000aa	8a 4d b3	 mov	 cl, BYTE PTR _curChar$1[ebp]
  000ad	88 08		 mov	 BYTE PTR [eax], cl

; 103  : 			if (c < STRINGBUFF_LEN - 1)

  000af	81 7d bc ff 01
	00 00		 cmp	 DWORD PTR _c$2[ebp], 511 ; 000001ffH
  000b6	7d 0d		 jge	 SHORT $LN7@createFina

; 104  : 			{
; 105  : 				if (curChar == '\0')

  000b8	0f be 45 b3	 movsx	 eax, BYTE PTR _curChar$1[ebp]
  000bc	85 c0		 test	 eax, eax
  000be	75 05		 jne	 SHORT $LN7@createFina

; 106  : 				{
; 107  : 					return returnString;

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _returnString$[ebp]
  000c3	eb 23		 jmp	 SHORT $LN1@createFina
$LN7@createFina:

; 108  : 				}
; 109  : 			}
; 110  : 			curIdx++;

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _curIdx$[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 e0	 mov	 DWORD PTR _curIdx$[ebp], eax

; 111  : 		}

  000ce	eb b7		 jmp	 SHORT $LN4@createFina
$LN5@createFina:

; 112  : 		listNode = listNode->next;

  000d0	8b 45 d4	 mov	 eax, DWORD PTR _listNode$[ebp]
  000d3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d6	89 4d d4	 mov	 DWORD PTR _listNode$[ebp], ecx

; 113  : 	}

  000d9	eb 95		 jmp	 SHORT $LN2@createFina
$LN3@createFina:

; 114  : 	returnString[curIdx + 1] = '\0';

  000db	8b 45 ec	 mov	 eax, DWORD PTR _returnString$[ebp]
  000de	03 45 e0	 add	 eax, DWORD PTR _curIdx$[ebp]
  000e1	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 115  : 	return returnString;

  000e5	8b 45 ec	 mov	 eax, DWORD PTR _returnString$[ebp]
$LN1@createFina:

; 116  : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
_createFinalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanident
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = 8							; size = 4
_buf$ = 12						; size = 4
_lim$ = 16						; size = 4
_scanident PROC						; COMDAT

; 11   : int scanident(int c, char* buf, int lim) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 12   : 	int i = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@scanident:

; 13   : 
; 14   : 	// Allow digits, alpha and underscores
; 15   : 	while (isalpha(c) || isdigit(c) || '_' == c) {

  0002f	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _isalpha
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	75 16		 jne	 SHORT $LN4@scanident
  0003f	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _isdigit
  00048	83 c4 04	 add	 esp, 4
  0004b	85 c0		 test	 eax, eax
  0004d	75 06		 jne	 SHORT $LN4@scanident
  0004f	83 7d 08 5f	 cmp	 DWORD PTR _c$[ebp], 95	; 0000005fH
  00053	75 5a		 jne	 SHORT $LN3@scanident
$LN4@scanident:

; 16   : 		// Error if we hit the identifier length limit,
; 17   : 		// else append to buf[] and get next character
; 18   : 		if (lim - 1 == i) {

  00055	8b 45 10	 mov	 eax, DWORD PTR _lim$[ebp]
  00058	83 e8 01	 sub	 eax, 1
  0005b	3b 45 f8	 cmp	 eax, DWORD PTR _i$[ebp]
  0005e	75 26		 jne	 SHORT $LN5@scanident

; 19   : 			printf("identifier too long line %d\n", Line);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  00065	50		 push	 eax
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DJPDDNIE@identifier?5too?5long?5line?5?$CFd?6@
  0006b	e8 00 00 00 00	 call	 _printf
  00070	83 c4 08	 add	 esp, 8

; 20   : 			exit(1);

  00073	8b f4		 mov	 esi, esp
  00075	6a 01		 push	 1
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0007d	3b f4		 cmp	 esi, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 21   : 		}

  00084	eb 1f		 jmp	 SHORT $LN6@scanident
$LN5@scanident:

; 22   : 		else if (i < lim - 1) {

  00086	8b 45 10	 mov	 eax, DWORD PTR _lim$[ebp]
  00089	83 e8 01	 sub	 eax, 1
  0008c	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0008f	7d 14		 jge	 SHORT $LN6@scanident

; 23   : 			buf[i++] = c;

  00091	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00094	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  00097	8a 4d 08	 mov	 cl, BYTE PTR _c$[ebp]
  0009a	88 08		 mov	 BYTE PTR [eax], cl
  0009c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0009f	83 c2 01	 add	 edx, 1
  000a2	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN6@scanident:

; 24   : 		}
; 25   : 		c = next();

  000a5	e8 00 00 00 00	 call	 _next
  000aa	89 45 08	 mov	 DWORD PTR _c$[ebp], eax

; 26   : 	}

  000ad	eb 80		 jmp	 SHORT $LN2@scanident
$LN3@scanident:

; 27   : 	// We hit a non-valid character, put it back.
; 28   : 	// NUL-terminate the buf[] and return the length
; 29   : 	putback(c);

  000af	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _putback
  000b8	83 c4 04	 add	 esp, 4

; 30   : 	buf[i] = '\0';

  000bb	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000be	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  000c1	c6 00 00	 mov	 BYTE PTR [eax], 0

; 31   : 	return (i);

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
$LN8@scanident:

; 32   : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000d0	3b ec		 cmp	 ebp, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
_scanident ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scanIntAndFloat
_TEXT	SEGMENT
tv243 = -380						; size = 8
_intStruct$ = -176					; size = 24
_floatStruct$1 = -144					; size = 24
_floatVal$2 = -112					; size = 8
_divNum$3 = -96						; size = 8
_firstNum$ = -80					; size = 4
_dotPos$ = -68						; size = 4
_count$ = -56						; size = 4
_isFloat$ = -44						; size = 4
_k$ = -32						; size = 8
_val$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
$T4 = 8							; size = 4
_c$ = 12						; size = 4
_scanIntAndFloat PROC					; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 84 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-380]
  00012	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 237  : 	INT_VAL val = 0;

  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	66 0f 13 45 f0	 movlpd	 QWORD PTR _val$[ebp], xmm0

; 238  : 	INT_VAL k;
; 239  : 
; 240  : 	int isFloat = 0;

  0003a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _isFloat$[ebp], 0

; 241  : 	int count = 0;

  00041	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 242  : 	int dotPos = -1;

  00048	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR _dotPos$[ebp], -1

; 243  : 	int firstNum = 9;

  0004f	c7 45 b0 09 00
	00 00		 mov	 DWORD PTR _firstNum$[ebp], 9
$LN2@scanIntAnd:

; 244  : 	while ((k = chrpos("0123456789", c)) >= 0 || c == '.') {

  00056	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00059	50		 push	 eax
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FPFMPDDA@0123456789@
  0005f	e8 00 00 00 00	 call	 _chrpos
  00064	83 c4 08	 add	 esp, 8
  00067	99		 cdq
  00068	89 45 e0	 mov	 DWORD PTR _k$[ebp], eax
  0006b	89 55 e4	 mov	 DWORD PTR _k$[ebp+4], edx
  0006e	83 7d e4 00	 cmp	 DWORD PTR _k$[ebp+4], 0
  00072	7f 0e		 jg	 SHORT $LN4@scanIntAnd
  00074	7c 06		 jl	 SHORT $LN12@scanIntAnd
  00076	83 7d e0 00	 cmp	 DWORD PTR _k$[ebp], 0
  0007a	73 06		 jae	 SHORT $LN4@scanIntAnd
$LN12@scanIntAnd:
  0007c	83 7d 0c 2e	 cmp	 DWORD PTR _c$[ebp], 46	; 0000002eH
  00080	75 58		 jne	 SHORT $LN3@scanIntAnd
$LN4@scanIntAnd:

; 245  : 		if (count == 0)

  00082	83 7d c8 00	 cmp	 DWORD PTR _count$[ebp], 0
  00086	75 06		 jne	 SHORT $LN5@scanIntAnd

; 246  : 		{
; 247  : 			firstNum = (int)k;

  00088	8b 45 e0	 mov	 eax, DWORD PTR _k$[ebp]
  0008b	89 45 b0	 mov	 DWORD PTR _firstNum$[ebp], eax
$LN5@scanIntAnd:

; 248  : 		}
; 249  : 		count++;

  0008e	8b 45 c8	 mov	 eax, DWORD PTR _count$[ebp]
  00091	83 c0 01	 add	 eax, 1
  00094	89 45 c8	 mov	 DWORD PTR _count$[ebp], eax

; 250  : 		if (c == '.')

  00097	83 7d 0c 2e	 cmp	 DWORD PTR _c$[ebp], 46	; 0000002eH
  0009b	75 0d		 jne	 SHORT $LN6@scanIntAnd

; 251  : 		{
; 252  : 			isFloat = 1;

  0009d	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _isFloat$[ebp], 1

; 253  : 			dotPos = count;

  000a4	8b 45 c8	 mov	 eax, DWORD PTR _count$[ebp]
  000a7	89 45 bc	 mov	 DWORD PTR _dotPos$[ebp], eax
$LN6@scanIntAnd:

; 254  : 		}
; 255  : 		if (c != '.')

  000aa	83 7d 0c 2e	 cmp	 DWORD PTR _c$[ebp], 46	; 0000002eH
  000ae	74 1d		 je	 SHORT $LN7@scanIntAnd

; 256  : 		{
; 257  : 			val = val * 10 + k;

  000b0	6a 00		 push	 0
  000b2	6a 0a		 push	 10			; 0000000aH
  000b4	8b 45 f4	 mov	 eax, DWORD PTR _val$[ebp+4]
  000b7	50		 push	 eax
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _val$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 __allmul
  000c1	03 45 e0	 add	 eax, DWORD PTR _k$[ebp]
  000c4	13 55 e4	 adc	 edx, DWORD PTR _k$[ebp+4]
  000c7	89 45 f0	 mov	 DWORD PTR _val$[ebp], eax
  000ca	89 55 f4	 mov	 DWORD PTR _val$[ebp+4], edx
$LN7@scanIntAnd:

; 258  : 		}
; 259  : 		c = next();

  000cd	e8 00 00 00 00	 call	 _next
  000d2	89 45 0c	 mov	 DWORD PTR _c$[ebp], eax

; 260  : 	}

  000d5	e9 7c ff ff ff	 jmp	 $LN2@scanIntAnd
$LN3@scanIntAnd:

; 261  : 	putback(c);

  000da	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _putback
  000e3	83 c4 04	 add	 esp, 4

; 262  : 
; 263  : 	if (isFloat)

  000e6	83 7d d4 00	 cmp	 DWORD PTR _isFloat$[ebp], 0
  000ea	0f 84 be 00 00
	00		 je	 $LN8@scanIntAnd

; 264  : 	{
; 265  : 
; 266  : 		if (count >= 19)
; 267  : 		{
; 268  : 			/*intf("[STACK ERROR] number has to many digits  (Line %d)\n", Line);
; 269  : 			exit(1);*/
; 270  : 		}
; 271  : 		INT_VAL divNum = (INT_VAL)pow(10, ((double)count - dotPos));

  000f0	f2 0f 2a 45 c8	 cvtsi2sd xmm0, DWORD PTR _count$[ebp]
  000f5	f2 0f 2a 4d bc	 cvtsi2sd xmm1, DWORD PTR _dotPos$[ebp]
  000fa	f2 0f 5c c1	 subsd	 xmm0, xmm1
  000fe	83 ec 08	 sub	 esp, 8
  00101	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00106	83 ec 08	 sub	 esp, 8
  00109	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  00111	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00116	e8 00 00 00 00	 call	 _pow
  0011b	83 c4 10	 add	 esp, 16			; 00000010H
  0011e	e8 00 00 00 00	 call	 __ftol2
  00123	89 45 a0	 mov	 DWORD PTR _divNum$3[ebp], eax
  00126	89 55 a4	 mov	 DWORD PTR _divNum$3[ebp+4], edx

; 272  : 		double floatVal = (double)val / (double)divNum;

  00129	8b 55 f4	 mov	 edx, DWORD PTR _val$[ebp+4]
  0012c	8b 4d f0	 mov	 ecx, DWORD PTR _val$[ebp]
  0012f	e8 00 00 00 00	 call	 __ltod3
  00134	8b 55 a4	 mov	 edx, DWORD PTR _divNum$3[ebp+4]
  00137	8b 4d a0	 mov	 ecx, DWORD PTR _divNum$3[ebp]
  0013a	f2 0f 11 85 84
	fe ff ff	 movsd	 QWORD PTR tv243[ebp], xmm0
  00142	e8 00 00 00 00	 call	 __ltod3
  00147	f2 0f 10 8d 84
	fe ff ff	 movsd	 xmm1, QWORD PTR tv243[ebp]
  0014f	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00153	f2 0f 11 4d 90	 movsd	 QWORD PTR _floatVal$2[ebp], xmm1

; 273  : 		struct NumericVal floatStruct = { 0, floatVal, TT_FLOAT };

  00158	0f 57 c0	 xorps	 xmm0, xmm0
  0015b	66 0f 13 85 70
	ff ff ff	 movlpd	 QWORD PTR _floatStruct$1[ebp], xmm0
  00163	f2 0f 10 45 90	 movsd	 xmm0, QWORD PTR _floatVal$2[ebp]
  00168	f2 0f 11 85 78
	ff ff ff	 movsd	 QWORD PTR _floatStruct$1[ebp+8], xmm0
  00170	c7 45 80 10 00
	00 00		 mov	 DWORD PTR _floatStruct$1[ebp+16], 16 ; 00000010H

; 274  : 		return floatStruct;

  00177	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  0017a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _floatStruct$1[ebp]
  00180	89 08		 mov	 DWORD PTR [eax], ecx
  00182	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _floatStruct$1[ebp+4]
  00188	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0018b	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _floatStruct$1[ebp+8]
  00191	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00194	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _floatStruct$1[ebp+12]
  0019a	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0019d	8b 4d 80	 mov	 ecx, DWORD PTR _floatStruct$1[ebp+16]
  001a0	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  001a3	8b 55 84	 mov	 edx, DWORD PTR _floatStruct$1[ebp+20]
  001a6	89 50 14	 mov	 DWORD PTR [eax+20], edx
  001a9	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  001ac	eb 62		 jmp	 SHORT $LN1@scanIntAnd
$LN8@scanIntAnd:

; 275  : 	}
; 276  : 
; 277  : 	if (count >= 10 && firstNum > 1)
; 278  : 	{
; 279  : 		/*printf("[STACK ERROR] number has to many digits  (Line %d)\n", Line);
; 280  : 		exit(1)*/
; 281  : 	}
; 282  : 
; 283  : 
; 284  : 	struct NumericVal intStruct = { val, 0, TT_INT };

  001ae	8b 45 f0	 mov	 eax, DWORD PTR _val$[ebp]
  001b1	89 85 50 ff ff
	ff		 mov	 DWORD PTR _intStruct$[ebp], eax
  001b7	8b 4d f4	 mov	 ecx, DWORD PTR _val$[ebp+4]
  001ba	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _intStruct$[ebp+4], ecx
  001c0	0f 57 c0	 xorps	 xmm0, xmm0
  001c3	f2 0f 11 85 58
	ff ff ff	 movsd	 QWORD PTR _intStruct$[ebp+8], xmm0
  001cb	c7 85 60 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _intStruct$[ebp+16], 5

; 285  : 	return intStruct;

  001d5	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
  001d8	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _intStruct$[ebp]
  001de	89 08		 mov	 DWORD PTR [eax], ecx
  001e0	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _intStruct$[ebp+4]
  001e6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  001e9	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _intStruct$[ebp+8]
  001ef	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001f2	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _intStruct$[ebp+12]
  001f8	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  001fb	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _intStruct$[ebp+16]
  00201	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00204	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _intStruct$[ebp+20]
  0020a	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0020d	8b 45 08	 mov	 eax, DWORD PTR $T4[ebp]
$LN1@scanIntAnd:

; 286  : }

  00210	52		 push	 edx
  00211	8b cd		 mov	 ecx, ebp
  00213	50		 push	 eax
  00214	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@scanIntAnd
  0021a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0021f	58		 pop	 eax
  00220	5a		 pop	 edx
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00227	33 cd		 xor	 ecx, ebp
  00229	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022e	81 c4 7c 01 00
	00		 add	 esp, 380		; 0000017cH
  00234	3b ec		 cmp	 ebp, esp
  00236	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0023b	8b e5		 mov	 esp, ebp
  0023d	5d		 pop	 ebp
  0023e	c3		 ret	 0
  0023f	90		 npad	 1
$LN16@scanIntAnd:
  00240	02 00 00 00	 DD	 2
  00244	00 00 00 00	 DD	 $LN15@scanIntAnd
$LN15@scanIntAnd:
  00248	70 ff ff ff	 DD	 -144			; ffffff70H
  0024c	18 00 00 00	 DD	 24			; 00000018H
  00250	00 00 00 00	 DD	 $LN13@scanIntAnd
  00254	50 ff ff ff	 DD	 -176			; ffffff50H
  00258	18 00 00 00	 DD	 24			; 00000018H
  0025c	00 00 00 00	 DD	 $LN14@scanIntAnd
$LN14@scanIntAnd:
  00260	69		 DB	 105			; 00000069H
  00261	6e		 DB	 110			; 0000006eH
  00262	74		 DB	 116			; 00000074H
  00263	53		 DB	 83			; 00000053H
  00264	74		 DB	 116			; 00000074H
  00265	72		 DB	 114			; 00000072H
  00266	75		 DB	 117			; 00000075H
  00267	63		 DB	 99			; 00000063H
  00268	74		 DB	 116			; 00000074H
  00269	00		 DB	 0
$LN13@scanIntAnd:
  0026a	66		 DB	 102			; 00000066H
  0026b	6c		 DB	 108			; 0000006cH
  0026c	6f		 DB	 111			; 0000006fH
  0026d	61		 DB	 97			; 00000061H
  0026e	74		 DB	 116			; 00000074H
  0026f	53		 DB	 83			; 00000053H
  00270	74		 DB	 116			; 00000074H
  00271	72		 DB	 114			; 00000072H
  00272	75		 DB	 117			; 00000075H
  00273	63		 DB	 99			; 00000063H
  00274	74		 DB	 116			; 00000074H
  00275	00		 DB	 0
_scanIntAndFloat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _chrpos
_TEXT	SEGMENT
tv69 = -208						; size = 4
_p$ = -8						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_chrpos	PROC						; COMDAT

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 228  : 	char* p;
; 229  : 
; 230  : 	p = strchr(s, c);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 _strchr
  00035	83 c4 08	 add	 esp, 8
  00038	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 231  : 	return (p ? p - s : -1);

  0003b	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  0003f	74 0e		 je	 SHORT $LN3@chrpos
  00041	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00044	2b 45 08	 sub	 eax, DWORD PTR _s$[ebp]
  00047	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0004d	eb 0a		 jmp	 SHORT $LN4@chrpos
$LN3@chrpos:
  0004f	c7 85 30 ff ff
	ff ff ff ff ff	 mov	 DWORD PTR tv69[ebp], -1
$LN4@chrpos:
  00059	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 232  : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_chrpos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _scan_tokens
_TEXT	SEGMENT
_c$ = -8						; size = 4
_tokenList$ = 8						; size = 4
_t$ = 12						; size = 4
_scan_tokens PROC					; COMDAT

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 300  : 	int c = 0;

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _c$[ebp], 0
$LN2@scan_token:

; 301  : 
; 302  : 	while (c != EOF)

  0002f	83 7d f8 ff	 cmp	 DWORD PTR _c$[ebp], -1
  00033	74 02		 je	 SHORT $LN1@scan_token

; 303  : 	{
; 304  : 		//scan_curToken(tokenList, t, c);
; 305  : 	}

  00035	eb f8		 jmp	 SHORT $LN2@scan_token
$LN1@scan_token:

; 306  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
_scan_tokens ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _skip
_TEXT	SEGMENT
_c$ = -8						; size = 4
_skip	PROC						; COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 215  : 	int c;
; 216  : 
; 217  : 	c = next();

  00028	e8 00 00 00 00	 call	 _next
  0002d	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
$LN2@skip:

; 218  : 	while (' ' == c || '\t' == c || '\n' == c || '\r' == c || '\f' == c)

  00030	83 7d f8 20	 cmp	 DWORD PTR _c$[ebp], 32	; 00000020H
  00034	74 18		 je	 SHORT $LN4@skip
  00036	83 7d f8 09	 cmp	 DWORD PTR _c$[ebp], 9
  0003a	74 12		 je	 SHORT $LN4@skip
  0003c	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00040	74 0c		 je	 SHORT $LN4@skip
  00042	83 7d f8 0d	 cmp	 DWORD PTR _c$[ebp], 13	; 0000000dH
  00046	74 06		 je	 SHORT $LN4@skip
  00048	83 7d f8 0c	 cmp	 DWORD PTR _c$[ebp], 12	; 0000000cH
  0004c	75 0a		 jne	 SHORT $LN3@skip
$LN4@skip:

; 219  : 	{
; 220  : 		c = next();

  0004e	e8 00 00 00 00	 call	 _next
  00053	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 221  : 	}

  00056	eb d8		 jmp	 SHORT $LN2@skip
$LN3@skip:

; 222  : 	return c;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]

; 223  : }

  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00064	3b ec		 cmp	 ebp, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _putback
_TEXT	SEGMENT
_c$ = 8							; size = 4
_putback PROC						; COMDAT

; 209  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 210  : 	Putback = c;

  00028	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0002b	a3 00 00 00 00	 mov	 DWORD PTR _Putback, eax

; 211  : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_putback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\scan.c
;	COMDAT _next
_TEXT	SEGMENT
_c$ = -8						; size = 4
_next	PROC						; COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __56B56370_scan@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 193  : 	int c;
; 194  : 
; 195  : 	if (Putback)

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Putback, 0
  0002f	74 17		 je	 SHORT $LN2@next

; 196  : 	{
; 197  : 		c = Putback;

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _Putback
  00036	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 198  : 		Putback = 0;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Putback, 0

; 199  : 		return c;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  00046	eb 31		 jmp	 SHORT $LN1@next
$LN2@next:

; 200  : 	}
; 201  : 
; 202  : 	c = fgetc(Infile);

  00048	8b f4		 mov	 esi, esp
  0004a	a1 00 00 00 00	 mov	 eax, DWORD PTR _Infile
  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgetc
  00056	83 c4 04	 add	 esp, 4
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 203  : 	if ('\n' == c)

  00063	83 7d f8 0a	 cmp	 DWORD PTR _c$[ebp], 10	; 0000000aH
  00067	75 0d		 jne	 SHORT $LN3@next

; 204  : 		Line++;

  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _Line
  0006e	83 c0 01	 add	 eax, 1
  00071	a3 00 00 00 00	 mov	 DWORD PTR _Line, eax
$LN3@next:

; 205  : 	return c;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@next:

; 206  : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_next	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_identToken
_TEXT	SEGMENT
_initToken$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_line$ = 12						; size = 4
_identToken_name$ = 16					; size = 4
_identToken_data$ = 20					; size = 8
_data$ = 28						; size = 4
_newToken_identToken PROC				; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 232  : 	struct Token* initToken = malloc(sizeof(struct Token));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 38		 push	 56			; 00000038H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initToken$[ebp], eax

; 233  : 	initToken->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 234  : 	initToken->intValue = 0;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  0004a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00051	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 235  : 	initToken->line = line;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  0005b	8b 4d 0c	 mov	 ecx, DWORD PTR _line$[ebp]
  0005e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 236  : 	initToken->strVal = NULL;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00064	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 237  : 	initToken->floatVal = 0;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  0006e	0f 57 c0	 xorps	 xmm0, xmm0
  00071	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 238  : 	initToken->IdentToken_name = identToken_name;

  00076	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00079	8b 4d 10	 mov	 ecx, DWORD PTR _identToken_name$[ebp]
  0007c	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 239  : 	initToken->IdentToken_data = identToken_data;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00082	8b 4d 14	 mov	 ecx, DWORD PTR _identToken_data$[ebp]
  00085	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00088	8b 55 18	 mov	 edx, DWORD PTR _identToken_data$[ebp+4]
  0008b	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 240  : 	initToken->data = data;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00091	8b 4d 1c	 mov	 ecx, DWORD PTR _data$[ebp]
  00094	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 241  : 	return initToken;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]

; 242  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_newToken_identToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_float
_TEXT	SEGMENT
_initToken_float$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_floatVal$ = 12						; size = 8
_line$ = 20						; size = 4
_data$ = 24						; size = 4
_newToken_float PROC					; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 218  : 	struct Token* initToken_float = malloc(sizeof(struct Token));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 38		 push	 56			; 00000038H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initToken_float$[ebp], eax

; 219  : 	initToken_float->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 220  : 	initToken_float->intValue = 0;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  0004a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00051	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 221  : 	initToken_float->line = line;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  0005b	8b 4d 14	 mov	 ecx, DWORD PTR _line$[ebp]
  0005e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 222  : 	initToken_float->strVal = NULL;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  00064	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 223  : 	initToken_float->floatVal = floatVal;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  0006e	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _floatVal$[ebp]
  00073	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 224  : 	initToken_float->IdentToken_name = NULL;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  0007b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 225  : 	initToken_float->IdentToken_data = 0;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  00085	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  0008c	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 226  : 	initToken_float->data = data;

  00093	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]
  00096	8b 4d 18	 mov	 ecx, DWORD PTR _data$[ebp]
  00099	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 227  : 	return initToken_float;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _initToken_float$[ebp]

; 228  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_newToken_float ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken_str
_TEXT	SEGMENT
_initToken_str$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_intValue$ = 12						; size = 8
_line$ = 20						; size = 4
_strVal$ = 24						; size = 4
_data$ = 28						; size = 4
_newToken_str PROC					; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 204  : 	struct Token* initToken_str = malloc(sizeof(struct Token));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 38		 push	 56			; 00000038H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initToken_str$[ebp], eax

; 205  : 	initToken_str->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 206  : 	initToken_str->intValue = intValue;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _intValue$[ebp]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00050	8b 55 10	 mov	 edx, DWORD PTR _intValue$[ebp+4]
  00053	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 207  : 	initToken_str->line = line;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00059	8b 4d 14	 mov	 ecx, DWORD PTR _line$[ebp]
  0005c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 208  : 	initToken_str->strVal = strVal;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00062	8b 4d 18	 mov	 ecx, DWORD PTR _strVal$[ebp]
  00065	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 209  : 	initToken_str->floatVal = 0;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 210  : 	initToken_str->IdentToken_name = NULL;

  00073	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00076	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 211  : 	initToken_str->IdentToken_data = 0;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00080	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  00087	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 212  : 	initToken_str->data = data;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]
  00091	8b 4d 1c	 mov	 ecx, DWORD PTR _data$[ebp]
  00094	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 213  : 	return initToken_str;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _initToken_str$[ebp]

; 214  : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_newToken_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _newToken
_TEXT	SEGMENT
_initToken$ = -8					; size = 4
_tokenType$ = 8						; size = 4
_intValue$ = 12						; size = 8
_line$ = 20						; size = 4
_data$ = 24						; size = 4
_newToken PROC						; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 190  : 	struct Token* initToken = malloc(sizeof(struct Token));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 38		 push	 56			; 00000038H
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _initToken$[ebp], eax

; 191  : 	initToken->tokenType = tokenType;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _tokenType$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 192  : 	initToken->intValue = intValue;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _intValue$[ebp]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00050	8b 55 10	 mov	 edx, DWORD PTR _intValue$[ebp+4]
  00053	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 193  : 	initToken->line = line;

  00056	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00059	8b 4d 14	 mov	 ecx, DWORD PTR _line$[ebp]
  0005c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 194  : 	initToken->strVal = NULL;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00062	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 195  : 	initToken->floatVal = 0;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f2 0f 11 40 18	 movsd	 QWORD PTR [eax+24], xmm0

; 196  : 	initToken->IdentToken_name = NULL;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00077	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 197  : 	initToken->IdentToken_data = 0;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00081	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  00088	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 198  : 	initToken->data = data;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]
  00092	8b 4d 18	 mov	 ecx, DWORD PTR _data$[ebp]
  00095	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 199  : 	return initToken;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _initToken$[ebp]

; 200  : }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000a4	3b ec		 cmp	 ebp, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_newToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _new_DATA_STRUCT
_TEXT	SEGMENT
_init$ = -8						; size = 4
_strVal$ = 8						; size = 4
_boolVal$ = 12						; size = 4
_doubleVal$ = 16					; size = 4
_intVal$ = 20						; size = 8
_charVal$ = 28						; size = 4
_dataType$ = 32						; size = 4
_minusVal$ = 36						; size = 4
_new_DATA_STRUCT PROC					; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __8478A1A4_tokens@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 29   : 	struct DATA_STRUCT* init = malloc(sizeof(struct DATA_STRUCT));

  00028	8b f4		 mov	 esi, esp
  0002a	6a 1c		 push	 28			; 0000001cH
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	89 45 f8	 mov	 DWORD PTR _init$[ebp], eax

; 30   : 	init->strVal = strVal;

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _strVal$[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 31   : 	init->boolVal = boolVal;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _boolVal$[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 32   : 	init->doubleVal = doubleVal;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _doubleVal$[ebp]
  00056	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 33   : 	init->intVal = intVal;

  00059	8b 45 14	 mov	 eax, DWORD PTR _intVal$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _init$[ebp]
  0005f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 34   : 	init->charVal = charVal;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00065	8b 4d 1c	 mov	 ecx, DWORD PTR _charVal$[ebp]
  00068	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 35   : 	init->dataType = dataType;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  0006e	8b 4d 20	 mov	 ecx, DWORD PTR _dataType$[ebp]
  00071	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 36   : 	init->minusVal = minusVal;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]
  00077	8b 4d 24	 mov	 ecx, DWORD PTR _minusVal$[ebp]
  0007a	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 37   : 	return init;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _init$[ebp]

; 38   : };

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_new_DATA_STRUCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00028	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0002b	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00037	51		 push	 ecx
  00038	8b f4		 mov	 esi, esp
  0003a	6a 01		 push	 1
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00042	83 c4 04	 add	 esp, 4
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 __vfprintf_l
  00052	83 c4 10	 add	 esp, 16			; 00000010H
  00055	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  00058	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __9FF75F13_stdio@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	51		 push	 ecx
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	52		 push	 edx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 644  :     }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __1850469A_corecrt_stdio_config@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00028	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
