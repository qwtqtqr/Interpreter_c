; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_05OODBEKIG@while@				; `string'
PUBLIC	??_C@_03MEPDGFMA@var@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8478A1A4_tokens@h DB 01H
__B4C58C4E_symtable@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var@
CONST	SEGMENT
??_C@_03MEPDGFMA@var@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while@
CONST	SEGMENT
??_C@_05OODBEKIG@while@ DB 'while', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
PUBLIC	_symtable_add
PUBLIC	_symtable_getItem
PUBLIC	_newID_token
PUBLIC	_symtable_removeItem
PUBLIC	_symtable_removeItem__test
PUBLIC	_getBucketVal
PUBLIC	_symtable_setItemVal
PUBLIC	__JustMyCode_Default
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_newLinkedList:PROC
EXTRN	_LinkedList_add_end:PROC
EXTRN	_LinkedList_size:PROC
EXTRN	_LinkedList_remove:PROC
EXTRN	_strcmp:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	__aullrem:PROC
EXTRN	__aullshr:PROC
EXTRN	_globl_symtable:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _symtable_setItemVal
_TEXT	SEGMENT
_curID$1 = -96						; size = 4
_varName_tail$2 = -84					; size = 4
_curID$3 = -72						; size = 4
_varName_head$4 = -60					; size = 4
_curNode_tail$ = -48					; size = 4
_curNode_head$ = -36					; size = 4
_bucket$ = -24						; size = 4
_hash$ = -12						; size = 8
_varName$ = 8						; size = 4
_value$ = 12						; size = 8
_symtable_setItemVal PROC				; COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 73   :     unsigned long long hash = hash_string(varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	call	_hash_string
	add	esp, 4
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 74   :     unsigned int bucket = getBucketVal(hash);

	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	_getBucketVal
	add	esp, 8
	mov	DWORD PTR _bucket$[ebp], eax

; 75   : 
; 76   :     if (globl_symtable[bucket] == NULL)

	mov	eax, DWORD PTR _bucket$[ebp]
	cmp	DWORD PTR _globl_symtable[eax*4], 0
	jne	SHORT $LN4@symtable_s

; 77   :     {
; 78   :         return;

	jmp	$LN1@symtable_s
$LN4@symtable_s:

; 79   :     }
; 80   :     node_t* curNode_head = globl_symtable[bucket]->head;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curNode_head$[ebp], edx

; 81   :     node_t* curNode_tail = globl_symtable[bucket]->tail;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _curNode_tail$[ebp], edx
$LN2@symtable_s:

; 82   : 
; 83   :     while (curNode_head != NULL && curNode_tail != NULL)

	cmp	DWORD PTR _curNode_head$[ebp], 0
	je	$LN1@symtable_s
	cmp	DWORD PTR _curNode_tail$[ebp], 0
	je	$LN1@symtable_s

; 84   :     {
; 85   :         char* varName_head = curNode_head->varName;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_head$4[ebp], ecx

; 86   :         if (strcmp(varName, varName_head) == 0)

	mov	eax, DWORD PTR _varName_head$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@symtable_s

; 87   :         {
; 88   :             struct IDENT_tokenData* curID = (struct IDENT_tokenData*)curNode_head->data;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curID$3[ebp], ecx

; 89   :             curID->value = value;

	mov	eax, DWORD PTR _curID$3[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [eax+20], edx

; 90   :             return;

	jmp	SHORT $LN1@symtable_s
$LN5@symtable_s:

; 91   :         }
; 92   :         char* varName_tail = curNode_tail->varName;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_tail$2[ebp], ecx

; 93   :         if (strcmp(varName, varName_tail) == 0)

	mov	eax, DWORD PTR _varName_tail$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@symtable_s

; 94   :         {
; 95   :             struct IDENT_tokenData* curID = (struct IDENT_tokenData*)curNode_head->data;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curID$1[ebp], ecx

; 96   :             curID->value = value;

	mov	eax, DWORD PTR _curID$1[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [eax+20], edx

; 97   :             return;

	jmp	SHORT $LN1@symtable_s
$LN6@symtable_s:

; 98   :         }
; 99   :         curNode_head = curNode_head->next;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _curNode_head$[ebp], ecx

; 100  :         curNode_tail = curNode_tail->last;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _curNode_tail$[ebp], ecx

; 101  :     }

	jmp	$LN2@symtable_s
$LN1@symtable_s:

; 102  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_symtable_setItemVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _getBucketVal
_TEXT	SEGMENT
_hash$ = 8						; size = 8
_getBucketVal PROC					; COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 25   :     return (unsigned int)(hash % SYMTABLE_SIZE);

	push	0
	push	5000					; 00001388H
	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	__aullrem

; 26   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getBucketVal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _hash_string
_TEXT	SEGMENT
_hash$ = -12						; size = 8
_s$ = 8							; size = 4
_hash_string PROC					; COMDAT

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 7    :     unsigned long long hash = 0;

	xorps	xmm0, xmm0
	movlpd	QWORD PTR _hash$[ebp], xmm0

; 8    : 
; 9    :     for (; *s; ++s)

	jmp	SHORT $LN4@hash_strin
$LN2@hash_strin:
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax
$LN4@hash_strin:
	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@hash_strin

; 10   :     {
; 11   :         hash += *s;

	mov	eax, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [eax]
	cdq
	add	eax, DWORD PTR _hash$[ebp]
	adc	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 12   :         hash += (hash << 10);

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]
	mov	cl, 10					; 0000000aH
	call	__allshl
	add	eax, DWORD PTR _hash$[ebp]
	adc	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 13   :         hash ^= (hash >> 6);

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]
	mov	cl, 6
	call	__aullshr
	xor	eax, DWORD PTR _hash$[ebp]
	xor	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 14   :     }

	jmp	SHORT $LN2@hash_strin
$LN3@hash_strin:

; 15   : 
; 16   :     hash += (hash << 3);

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]
	mov	cl, 3
	call	__allshl
	add	eax, DWORD PTR _hash$[ebp]
	adc	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 17   :     hash ^= (hash >> 11);

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]
	mov	cl, 11					; 0000000bH
	call	__aullshr
	xor	eax, DWORD PTR _hash$[ebp]
	xor	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 18   :     hash += (hash << 15);

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]
	mov	cl, 15					; 0000000fH
	call	__allshl
	add	eax, DWORD PTR _hash$[ebp]
	adc	edx, DWORD PTR _hash$[ebp+4]
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 19   : 
; 20   :     return hash;

	mov	eax, DWORD PTR _hash$[ebp]
	mov	edx, DWORD PTR _hash$[ebp+4]

; 21   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_hash_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _symtable_removeItem__test
_TEXT	SEGMENT
_varName_head$1 = -60					; size = 4
_cur_idx$ = -48						; size = 4
_curNode_head$ = -36					; size = 4
_bucket$ = -24						; size = 4
_hash$ = -12						; size = 8
_varName$ = 8						; size = 4
_symtable_removeItem__test PROC				; COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 145  :     unsigned long long hash = hash_string(varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	call	_hash_string
	add	esp, 4
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 146  :     unsigned int bucket = getBucketVal(hash);

	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	_getBucketVal
	add	esp, 8
	mov	DWORD PTR _bucket$[ebp], eax

; 147  : 
; 148  :     if (globl_symtable[bucket] == NULL)

	mov	eax, DWORD PTR _bucket$[ebp]
	cmp	DWORD PTR _globl_symtable[eax*4], 0
	jne	SHORT $LN4@symtable_r

; 149  :     {
; 150  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@symtable_r
$LN4@symtable_r:

; 151  :     }
; 152  :     node_t* curNode_head = globl_symtable[bucket]->head;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curNode_head$[ebp], edx

; 153  :     int cur_idx = 0;

	mov	DWORD PTR _cur_idx$[ebp], 0
$LN2@symtable_r:

; 154  :     while (curNode_head != NULL)

	cmp	DWORD PTR _curNode_head$[ebp], 0
	je	SHORT $LN3@symtable_r

; 155  :     {
; 156  :         char* varName_head = curNode_head->varName;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_head$1[ebp], ecx

; 157  :         if (strcmp(varName, varName_head) == 0)

	mov	eax, DWORD PTR _varName_head$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@symtable_r

; 158  :         {
; 159  :             if (curNode_head->data != NULL)
; 160  :             {
; 161  :                 //free(curNode_head->data);
; 162  :                 //curNode_head->data = NULL;
; 163  :             }
; 164  :             LinkedList_remove(globl_symtable[bucket], cur_idx);

	mov	eax, DWORD PTR _cur_idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bucket$[ebp]
	mov	edx, DWORD PTR _globl_symtable[ecx*4]
	push	edx
	call	_LinkedList_remove
	add	esp, 8

; 165  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@symtable_r
$LN5@symtable_r:

; 166  :         }
; 167  :        
; 168  :         cur_idx++;

	mov	eax, DWORD PTR _cur_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _cur_idx$[ebp], eax

; 169  :         curNode_head = curNode_head->next;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _curNode_head$[ebp], ecx

; 170  :     }

	jmp	SHORT $LN2@symtable_r
$LN3@symtable_r:

; 171  :     return -1;

	or	eax, -1
$LN1@symtable_r:

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_symtable_removeItem__test ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _symtable_removeItem
_TEXT	SEGMENT
_varname_tail$1 = -96					; size = 4
_varName_head$2 = -84					; size = 4
_curIndex_tail$ = -72					; size = 4
_curIndex_head$ = -60					; size = 4
_curNode_tail$ = -48					; size = 4
_curNode_head$ = -36					; size = 4
_bucket$ = -24						; size = 4
_hash$ = -12						; size = 8
_varName$ = 8						; size = 4
_symtable_removeItem PROC				; COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 107  :     unsigned long long hash = hash_string(varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	call	_hash_string
	add	esp, 4
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 108  :     unsigned int bucket = getBucketVal(hash);

	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	_getBucketVal
	add	esp, 8
	mov	DWORD PTR _bucket$[ebp], eax

; 109  : 
; 110  :     if (globl_symtable[bucket] == NULL)

	mov	eax, DWORD PTR _bucket$[ebp]
	cmp	DWORD PTR _globl_symtable[eax*4], 0
	jne	SHORT $LN4@symtable_r

; 111  :     {
; 112  :         return -1;

	or	eax, -1
	jmp	$LN1@symtable_r
$LN4@symtable_r:

; 113  :     }
; 114  :     node_t* curNode_head = globl_symtable[bucket]->head;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curNode_head$[ebp], edx

; 115  :     node_t* curNode_tail = globl_symtable[bucket]->tail;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _curNode_tail$[ebp], edx

; 116  :     int curIndex_head = 0;

	mov	DWORD PTR _curIndex_head$[ebp], 0

; 117  :     int curIndex_tail = LinkedList_size(globl_symtable[bucket]) - 1;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	push	ecx
	call	_LinkedList_size
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _curIndex_tail$[ebp], eax
$LN2@symtable_r:

; 118  :     while (curNode_head != NULL && curNode_tail != NULL && curNode_tail != curNode_head)

	cmp	DWORD PTR _curNode_head$[ebp], 0
	je	$LN3@symtable_r
	cmp	DWORD PTR _curNode_tail$[ebp], 0
	je	$LN3@symtable_r
	mov	eax, DWORD PTR _curNode_tail$[ebp]
	cmp	eax, DWORD PTR _curNode_head$[ebp]
	je	$LN3@symtable_r

; 119  :     {
; 120  :         char* varName_head = curNode_head->varName;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_head$2[ebp], ecx

; 121  :         if (strcmp(varName, varName_head) == 0)

	mov	eax, DWORD PTR _varName_head$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@symtable_r

; 122  :         {
; 123  :             free(curNode_head->data);

	mov	esi, esp
	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 124  :             LinkedList_remove(globl_symtable[bucket], curIndex_head);

	mov	eax, DWORD PTR _curIndex_head$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bucket$[ebp]
	mov	edx, DWORD PTR _globl_symtable[ecx*4]
	push	edx
	call	_LinkedList_remove
	add	esp, 8

; 125  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@symtable_r
$LN5@symtable_r:

; 126  :         }
; 127  :         char* varname_tail = curNode_tail->varName;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varname_tail$1[ebp], ecx

; 128  :         if (strcmp(varName, varName_head) == 0)

	mov	eax, DWORD PTR _varName_head$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@symtable_r

; 129  :         {
; 130  :             free(curNode_tail->data);

	mov	esi, esp
	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 131  :             LinkedList_remove(globl_symtable[bucket], curIndex_tail);

	mov	eax, DWORD PTR _curIndex_tail$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bucket$[ebp]
	mov	edx, DWORD PTR _globl_symtable[ecx*4]
	push	edx
	call	_LinkedList_remove
	add	esp, 8

; 132  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@symtable_r
$LN6@symtable_r:

; 133  :         }
; 134  :         curIndex_head++;

	mov	eax, DWORD PTR _curIndex_head$[ebp]
	add	eax, 1
	mov	DWORD PTR _curIndex_head$[ebp], eax

; 135  :         curIndex_tail--;

	mov	eax, DWORD PTR _curIndex_tail$[ebp]
	sub	eax, 1
	mov	DWORD PTR _curIndex_tail$[ebp], eax

; 136  :         curNode_head = curNode_head->next;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _curNode_head$[ebp], ecx

; 137  :         curNode_tail = curNode_tail->last;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _curNode_tail$[ebp], ecx

; 138  :     }

	jmp	$LN2@symtable_r
$LN3@symtable_r:

; 139  :     return -1;

	or	eax, -1
$LN1@symtable_r:

; 140  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_symtable_removeItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _newID_token
_TEXT	SEGMENT
_initID$ = -8						; size = 4
_dataType$ = 8						; size = 4
_init$ = 12						; size = 4
_value$ = 16						; size = 8
_varName$ = 24						; size = 4
_var$ = 28						; size = 4
_data$ = 32						; size = 4
_newID_token PROC					; COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 180  :     struct IDENT_tokenData* initID = malloc(sizeof(struct IDENT_tokenData));

	mov	esi, esp
	push	32					; 00000020H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initID$[ebp], eax

; 181  :     initID->dataType = dataType;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _dataType$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 182  :     initID->init = init;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _init$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 183  :     initID->value = value;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [eax+20], edx

; 184  :     initID->varName = varName;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _varName$[ebp]
	mov	DWORD PTR [eax], ecx

; 185  :     initID->var = var;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _var$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 186  :     initID->data = data;

	mov	eax, DWORD PTR _initID$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 187  :     return initID;

	mov	eax, DWORD PTR _initID$[ebp]

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_newID_token ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _symtable_getItem
_TEXT	SEGMENT
_varName_tail$1 = -72					; size = 4
_varName_head$2 = -60					; size = 4
_curNode_tail$ = -48					; size = 4
_curNode_head$ = -36					; size = 4
_bucket$ = -24						; size = 4
_hash$ = -12						; size = 8
_varName$ = 8						; size = 4
_symtable_getItem PROC					; COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 43   :     unsigned long long hash = hash_string(varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	call	_hash_string
	add	esp, 4
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 44   :     unsigned int bucket = getBucketVal(hash);

	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	_getBucketVal
	add	esp, 8
	mov	DWORD PTR _bucket$[ebp], eax

; 45   : 
; 46   :     if (globl_symtable[bucket] == NULL)

	mov	eax, DWORD PTR _bucket$[ebp]
	cmp	DWORD PTR _globl_symtable[eax*4], 0
	jne	SHORT $LN4@symtable_g

; 47   :     {
; 48   :         return NULL;

	xor	eax, eax
	jmp	$LN1@symtable_g
$LN4@symtable_g:

; 49   :     }
; 50   :     node_t* curNode_head = globl_symtable[bucket]->head;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _curNode_head$[ebp], edx

; 51   :     node_t* curNode_tail = globl_symtable[bucket]->tail;

	mov	eax, DWORD PTR _bucket$[ebp]
	mov	ecx, DWORD PTR _globl_symtable[eax*4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _curNode_tail$[ebp], edx
$LN2@symtable_g:

; 52   : 
; 53   :     while (curNode_head != NULL && curNode_tail != NULL)

	cmp	DWORD PTR _curNode_head$[ebp], 0
	je	SHORT $LN3@symtable_g
	cmp	DWORD PTR _curNode_tail$[ebp], 0
	je	SHORT $LN3@symtable_g

; 54   :     {
; 55   :         char* varName_head = curNode_head->varName;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_head$2[ebp], ecx

; 56   :         if (strcmp(varName, varName_head) == 0)

	mov	eax, DWORD PTR _varName_head$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@symtable_g

; 57   :         {
; 58   :             return (struct IDENT_tokenData*)curNode_head->data;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1@symtable_g
$LN5@symtable_g:

; 59   :         }
; 60   :         char* varName_tail = curNode_tail->varName;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _varName_tail$1[ebp], ecx

; 61   :         if (strcmp(varName, varName_tail) == 0)

	mov	eax, DWORD PTR _varName_tail$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _varName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@symtable_g

; 62   :         {
; 63   :             return (struct IDENT_tokenData*)curNode_tail->data;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN1@symtable_g
$LN6@symtable_g:

; 64   :         }
; 65   :         curNode_head = curNode_head->next;

	mov	eax, DWORD PTR _curNode_head$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _curNode_head$[ebp], ecx

; 66   :         curNode_tail = curNode_tail->last;

	mov	eax, DWORD PTR _curNode_tail$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _curNode_tail$[ebp], ecx

; 67   :     }

	jmp	SHORT $LN2@symtable_g
$LN3@symtable_g:

; 68   :     return NULL;

	xor	eax, eax
$LN1@symtable_g:

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_symtable_getItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\symtable.c
;	COMDAT _symtable_add
_TEXT	SEGMENT
_bucket$ = -24						; size = 4
_hash$ = -12						; size = 8
_varName$ = 8						; size = 4
_data$ = 12						; size = 4
_symtable_add PROC					; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B4C58C4E_symtable@c
	call	@__CheckForDebuggerJustMyCode@4

; 30   :     unsigned long long hash = hash_string(varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	call	_hash_string
	add	esp, 4
	mov	DWORD PTR _hash$[ebp], eax
	mov	DWORD PTR _hash$[ebp+4], edx

; 31   :     unsigned int bucket = getBucketVal(hash);

	mov	eax, DWORD PTR _hash$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	call	_getBucketVal
	add	esp, 8
	mov	DWORD PTR _bucket$[ebp], eax

; 32   : 
; 33   :     if (globl_symtable[bucket] == NULL)

	mov	eax, DWORD PTR _bucket$[ebp]
	cmp	DWORD PTR _globl_symtable[eax*4], 0
	jne	SHORT $LN2@symtable_a

; 34   :     {
; 35   :         globl_symtable[bucket] = newLinkedList();

	call	_newLinkedList
	mov	ecx, DWORD PTR _bucket$[ebp]
	mov	DWORD PTR _globl_symtable[ecx*4], eax
$LN2@symtable_a:

; 36   :     }
; 37   :     return LinkedList_add_end(globl_symtable[bucket], data, 0, NULL, varName);

	mov	eax, DWORD PTR _varName$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bucket$[ebp]
	mov	eax, DWORD PTR _globl_symtable[edx*4]
	push	eax
	call	_LinkedList_add_end
	add	esp, 20					; 00000014H

; 38   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_symtable_add ENDP
_TEXT	ENDS
END
