; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_globl_open_curly_count
PUBLIC	_globl_closed_curly_count
PUBLIC	_globl_current_depth
PUBLIC	??_C@_05IJDJACGD@print@				; `string'
PUBLIC	??_C@_02HEBPBKGD@if@				; `string'
PUBLIC	??_C@_05OODBEKIG@while@				; `string'
PUBLIC	??_C@_03MEPDGFMA@var@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04GNFOIEOK@elif@				; `string'
PUBLIC	??_C@_04FHMCPBIP@else@				; `string'
_BSS	SEGMENT
_globl_open_curly_count DD 01H DUP (?)
_globl_closed_curly_count DD 01H DUP (?)
_globl_current_depth DD 01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__8478A1A4_tokens@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__B5AFADD0_genAST@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_04FHMCPBIP@else@
CONST	SEGMENT
??_C@_04FHMCPBIP@else@ DB 'else', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GNFOIEOK@elif@
CONST	SEGMENT
??_C@_04GNFOIEOK@elif@ DB 'elif', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEPDGFMA@var@
CONST	SEGMENT
??_C@_03MEPDGFMA@var@ DB 'var', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OODBEKIG@while@
CONST	SEGMENT
??_C@_05OODBEKIG@while@ DB 'while', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HEBPBKGD@if@
CONST	SEGMENT
??_C@_02HEBPBKGD@if@ DB 'if', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJDJACGD@print@
CONST	SEGMENT
??_C@_05IJDJACGD@print@ DB 'print', 00H			; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_mkastnode
PUBLIC	_mkastnode_const
PUBLIC	_mkastnode_left
PUBLIC	_mkastnode_ident
PUBLIC	_binexpr
PUBLIC	_genMainAST
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@ ; `string'
PUBLIC	??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@ ; `string'
PUBLIC	??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ ; `string'
PUBLIC	??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@ ; `string'
PUBLIC	??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ ; `string'
PUBLIC	??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@ ; `string'
PUBLIC	??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@ ; `string'
PUBLIC	??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@ ; `string'
PUBLIC	??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@ ; `string'
PUBLIC	??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@ ; `string'
PUBLIC	??_C@_0FC@IKOHCIDM@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8eli@ ; `string'
PUBLIC	??_C@_0FC@OLDPBKN@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8els@ ; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__exit:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_newID_token:PROC
EXTRN	_genVarAST:PROC
EXTRN	_genIdentAST:PROC
EXTRN	_scan_curToken:PROC
EXTRN	_putBack_curToken:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	_Line:DWORD
EXTRN	_currentToken:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_leftParenCount DD 01H DUP (?)
_rightParenCount DD 01H DUP (?)
_globl_inParen DD 01H DUP (?)
_globl_parenDelta DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0FC@OLDPBKN@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8els@
CONST	SEGMENT
??_C@_0FC@OLDPBKN@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8els@ DB '[ERROR'
	DB	'] you cannot have an ''else'' statement without an ''if'' sta'
	DB	'tement (Line %d) ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@IKOHCIDM@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8eli@
CONST	SEGMENT
??_C@_0FC@IKOHCIDM@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8eli@ DB '[ERRO'
	DB	'R] you cannot have an ''elif'' statement without an ''if'' st'
	DB	'atement (Line %d) ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@
CONST	SEGMENT
??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@ DB '[SYNTAX'
	DB	' ERROR] expected an identifier (Line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@
CONST	SEGMENT
??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@ DB '['
	DB	'SYNTAX ERROR] expected an '';'' in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
CONST	SEGMENT
??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@ DB '['
	DB	'SYNTAX ERROR] ''('' is missing in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@
CONST	SEGMENT
??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@ DB '['
	DB	'SYNTAX ERROR] cannot use '';'' inside an expression (Line %d)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
CONST	SEGMENT
??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@ DB '['
	DB	'SYNTAX ERROR] expected a '';'' in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
CONST	SEGMENT
??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ DB '[SYNTAX'
	DB	' ERROR] expected a binary operator or '';'' (Line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@
CONST	SEGMENT
??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@ DB '[SYNTAX'
	DB	' ERROR] expected a number (Line %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
CONST	SEGMENT
??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@ DB '[SYNTAX'
	DB	' ERROR] expected a binary operator in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@
CONST	SEGMENT
??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@ DB '[SYNATX'
	DB	' ERROR] expected a number (Line %d) (Token %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
CONST	SEGMENT
??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@ DB '[SYNTAX '
	DB	'ERROR] unclosed parentheses in Line %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@ DB '[SYNTAX ERRO'
	DB	'R] Line %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_binOperators DD 00H
	DD	01H
	DD	02H
	DD	03H
	DD	06H
	DD	011H
	DD	04H
	DD	016H
	DD	01aH
	DD	01bH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	017H
	DD	018H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _getOpPrecedence
_TEXT	SEGMENT
tv65 = -208						; size = 4
_tt$ = -8						; size = 4
_t$ = 8							; size = 4
_getOpPrecedence PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 130  : 	int tt = t->tokenType;

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tt$[ebp], ecx

; 131  : 
; 132  : 	switch (tt)

	mov	eax, DWORD PTR _tt$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 30			; 0000001eH
	ja	SHORT $LN2@getOpPrece
	mov	ecx, DWORD PTR tv65[ebp]
	movzx	edx, BYTE PTR $LN21@getOpPrece[ecx]
	jmp	DWORD PTR $LN22@getOpPrece[edx*4]
$LN4@getOpPrece:

; 133  : 	{
; 134  : 	case TT_INT:              return 0;

	xor	eax, eax
	jmp	SHORT $LN1@getOpPrece
$LN5@getOpPrece:

; 135  : 	case TT_FLOAT:            return 0;

	xor	eax, eax
	jmp	SHORT $LN1@getOpPrece
$LN6@getOpPrece:

; 136  : 	case TT_PLUS:             return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN1@getOpPrece
$LN7@getOpPrece:

; 137  : 	case TT_MINUS:            return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN1@getOpPrece
$LN8@getOpPrece:

; 138  : 	case TT_MUL:	          return 20;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN1@getOpPrece
$LN9@getOpPrece:

; 139  : 	case TT_DIV:	          return 20;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN1@getOpPrece
$LN10@getOpPrece:

; 140  : 	case TT_OP_END:		      return 0;

	xor	eax, eax
	jmp	SHORT $LN1@getOpPrece
$LN11@getOpPrece:

; 141  : 	case TT_POW:	          return 25;

	mov	eax, 25					; 00000019H
	jmp	SHORT $LN1@getOpPrece
$LN12@getOpPrece:

; 142  : 	case TT_EQUALS_CMP:	      return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN13@getOpPrece:

; 143  : 	case TT_NOT_EQUALS:       return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN14@getOpPrece:

; 144  : 	case TT_GREATER:	      return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN15@getOpPrece:

; 145  : 	case TT_SMALLER:	      return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN16@getOpPrece:

; 146  : 	case TT_GREATER_EQUALS:	  return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN17@getOpPrece:

; 147  : 	case TT_SMALLER_EQUALS:   return 5;

	mov	eax, 5
	jmp	SHORT $LN1@getOpPrece
$LN18@getOpPrece:

; 148  : 	case TT_AND:              return 2;

	mov	eax, 2
	jmp	SHORT $LN1@getOpPrece
$LN19@getOpPrece:

; 149  : 	case TT_OR:               return 2;

	mov	eax, 2
	jmp	SHORT $LN1@getOpPrece
$LN2@getOpPrece:

; 150  : 	}
; 151  : 	return -1;

	or	eax, -1
$LN1@getOpPrece:

; 152  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@getOpPrece:
	DD	$LN6@getOpPrece
	DD	$LN7@getOpPrece
	DD	$LN8@getOpPrece
	DD	$LN9@getOpPrece
	DD	$LN11@getOpPrece
	DD	$LN4@getOpPrece
	DD	$LN10@getOpPrece
	DD	$LN5@getOpPrece
	DD	$LN12@getOpPrece
	DD	$LN18@getOpPrece
	DD	$LN19@getOpPrece
	DD	$LN13@getOpPrece
	DD	$LN14@getOpPrece
	DD	$LN15@getOpPrece
	DD	$LN16@getOpPrece
	DD	$LN17@getOpPrece
	DD	$LN2@getOpPrece
$LN21@getOpPrece:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	7
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	16					; 00000010H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
_getOpPrecedence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _rightParenCode
_TEXT	SEGMENT
_interrupt_token$ = 8					; size = 4
_rightParenCode PROC					; COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@rightParen:

; 61   : 	while (currentToken->tokenType == TT_RIGHT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 10			; 0000000aH
	jne	SHORT $LN3@rightParen

; 62   : 	{
; 63   : 		if (interrupt_token != -1)

	cmp	DWORD PTR _interrupt_token$[ebp], -1
	je	SHORT $LN4@rightParen

; 64   : 		{
; 65   : 			if (currentToken->tokenType == TT_RIGHT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 10			; 0000000aH
	jne	SHORT $LN4@rightParen

; 66   : 			{
; 67   : 				scan_curToken();

	call	_scan_curToken

; 68   : 				if (currentToken->tokenType == interrupt_token)

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _interrupt_token$[ebp]
	jne	SHORT $LN6@rightParen

; 69   : 				{
; 70   : 					rightParenCount = 0;

	mov	DWORD PTR _rightParenCount, 0

; 71   : 					leftParenCount = 0;

	mov	DWORD PTR _leftParenCount, 0

; 72   : 					putBack_curToken(currentToken);

	mov	eax, DWORD PTR _currentToken
	push	eax
	call	_putBack_curToken
	add	esp, 4

; 73   : 					return 1;

	mov	eax, 1
	jmp	$LN12@rightParen
$LN6@rightParen:

; 74   : 				}
; 75   : 				putBack_curToken(currentToken);

	mov	eax, DWORD PTR _currentToken
	push	eax
	call	_putBack_curToken
	add	esp, 4
$LN4@rightParen:

; 76   : 			}
; 77   : 		}
; 78   : 		rightParenCount++;

	mov	eax, DWORD PTR _rightParenCount
	add	eax, 1
	mov	DWORD PTR _rightParenCount, eax

; 79   : 		scan_curToken();

	call	_scan_curToken

; 80   : 	}

	jmp	SHORT $LN2@rightParen
$LN3@rightParen:

; 81   : 
; 82   : 	if (leftParenCount != rightParenCount)

	mov	eax, DWORD PTR _leftParenCount
	cmp	eax, DWORD PTR _rightParenCount
	je	SHORT $LN7@rightParen

; 83   : 	{
; 84   : 		globl_inParen = PAREN_PRECEDENCE;

	mov	DWORD PTR _globl_inParen, 20		; 00000014H

; 85   : 		globl_parenDelta = leftParenCount - rightParenCount;

	mov	eax, DWORD PTR _leftParenCount
	sub	eax, DWORD PTR _rightParenCount
	mov	DWORD PTR _globl_parenDelta, eax
$LN7@rightParen:

; 86   : 	}
; 87   : 
; 88   : 	if (leftParenCount == rightParenCount)

	mov	eax, DWORD PTR _leftParenCount
	cmp	eax, DWORD PTR _rightParenCount
	jne	SHORT $LN8@rightParen

; 89   : 	{
; 90   : 		globl_inParen = 0;

	mov	DWORD PTR _globl_inParen, 0

; 91   : 		leftParenCount = 0;

	mov	DWORD PTR _leftParenCount, 0

; 92   : 		rightParenCount = 0;

	mov	DWORD PTR _rightParenCount, 0

; 93   : 		globl_parenDelta = 0;

	mov	DWORD PTR _globl_parenDelta, 0
$LN8@rightParen:

; 94   : 	}
; 95   : 
; 96   : 	if (currentToken->tokenType == TT_OP_END && leftParenCount != rightParenCount)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN9@rightParen
	mov	eax, DWORD PTR _leftParenCount
	cmp	eax, DWORD PTR _rightParenCount
	je	SHORT $LN9@rightParen

; 97   : 	{
; 98   : 		printf("[SYNTAX ERROR] unclosed parentheses in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
	call	_printf
	add	esp, 8

; 99   : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@rightParen:

; 100  : 	}
; 101  : 	if (currentToken->tokenType == TT_INT || currentToken->tokenType == TT_FLOAT)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN11@rightParen
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 16			; 00000010H
	jne	SHORT $LN10@rightParen
$LN11@rightParen:

; 102  : 	{
; 103  : 		printf("[SYNTAX ERROR] expected a binary operator in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0DG@BHFFDDHI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
	call	_printf
	add	esp, 8

; 104  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@rightParen:

; 105  : 	}
; 106  : 	return 0;

	xor	eax, eax
$LN12@rightParen:

; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_rightParenCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _tokenIsBinOp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_t$ = 8							; size = 4
_tokenIsBinOp PROC					; COMDAT

; 155  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 156  : 	for (size_t i = 0; i < arraySize(binOperators); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@tokenIsBin
$LN2@tokenIsBin:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@tokenIsBin:
	cmp	DWORD PTR _i$1[ebp], 15			; 0000000fH
	jae	SHORT $LN3@tokenIsBin

; 157  : 	{
; 158  : 		if (t->tokenType == binOperators[i])

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _binOperators[ecx*4]
	jne	SHORT $LN5@tokenIsBin

; 159  : 		{
; 160  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN1@tokenIsBin
$LN5@tokenIsBin:

; 161  : 		}
; 162  : 	}

	jmp	SHORT $LN2@tokenIsBin
$LN3@tokenIsBin:

; 163  : 	return 0;

	xor	eax, eax
$LN1@tokenIsBin:

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tokenIsBinOp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _leftParenCode
_TEXT	SEGMENT
_minusToken$ = 8					; size = 4
_leftParenCode PROC					; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@leftParenC:

; 36   : 	while (currentToken->tokenType == TT_LEFT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 9
	jne	$LN8@leftParenC

; 37   : 	{
; 38   : 		leftParenCount++;

	mov	eax, DWORD PTR _leftParenCount
	add	eax, 1
	mov	DWORD PTR _leftParenCount, eax

; 39   : 		if (minusToken->tokenType == TT_MINUS)

	mov	eax, DWORD PTR _minusToken$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN4@leftParenC

; 40   : 		{
; 41   : 			printf("[SYNTAX ERROR] Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0BI@COOHKODO@?$FLSYNTAX?5ERROR?$FN?5Line?5?$CFd?6@
	call	_printf
	add	esp, 8

; 42   : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@leftParenC:

; 43   : 		}
; 44   : 		scan_curToken();

	call	_scan_curToken

; 45   : 		if (currentToken->tokenType == TT_EOF || currentToken->tokenType == TT_OP_END)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 17			; 00000011H
	je	SHORT $LN6@leftParenC
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN5@leftParenC
$LN6@leftParenC:

; 46   : 		{
; 47   : 			printf("[SYNTAX ERROR] unclosed parentheses in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0DA@JFFIKNMC@?$FLSYNTAX?5ERROR?$FN?5unclosed?5parenth@
	call	_printf
	add	esp, 8

; 48   : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@leftParenC:

; 49   : 		}
; 50   : 		if (tokenIsBinOp(currentToken))

	mov	eax, DWORD PTR _currentToken
	push	eax
	call	_tokenIsBinOp
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@leftParenC

; 51   : 		{
; 52   : 			printf("[SYNATX ERROR] expected a number (Line %d) (Token %d)\n", Line, currentToken->tokenType);

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Line
	push	edx
	push	OFFSET ??_C@_0DH@IGEDBLBP@?$FLSYNATX?5ERROR?$FN?5expected?5a?5numbe@
	call	_printf
	add	esp, 12					; 0000000cH

; 53   : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@leftParenC:

; 54   : 		}
; 55   : 	}

	jmp	$LN2@leftParenC
$LN8@leftParenC:

; 56   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_leftParenCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _genMainAST
_TEXT	SEGMENT
tv65 = -256						; size = 4
_varName_save$1 = -56					; size = 4
_t$ = -44						; size = 4
_node$ = -32						; size = 4
_right$ = -20						; size = 4
_left$ = -8						; size = 4
_scope_depth$ = 8					; size = 4
_scope_mode$ = 12					; size = 4
_if_init$ = 16						; size = 4
_genMainAST PROC					; COMDAT

; 321  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 322  : 	struct AST_Node* left = NULL, * right = NULL, * node = NULL;

	mov	DWORD PTR _left$[ebp], 0
	mov	DWORD PTR _right$[ebp], 0
	mov	DWORD PTR _node$[ebp], 0

; 323  : 	scan_curToken();

	call	_scan_curToken

; 324  : 
; 325  : 
; 326  : 	struct Token* t = currentToken;

	mov	eax, DWORD PTR _currentToken
	mov	DWORD PTR _t$[ebp], eax

; 327  : 
; 328  : 	switch (currentToken->tokenType)

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv65[ebp], ecx
	mov	edx, DWORD PTR tv65[ebp]
	sub	edx, 7
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 29			; 0000001dH
	ja	$LN2@genMainAST
	mov	eax, DWORD PTR tv65[ebp]
	movzx	ecx, BYTE PTR $LN27@genMainAST[eax]
	jmp	DWORD PTR $LN28@genMainAST[ecx*4]
$LN4@genMainAST:

; 329  : 	{
; 330  : 	case TT_PRINT:
; 331  : 
; 332  : 		scan_curToken();

	call	_scan_curToken

; 333  : 		if (currentToken->tokenType != TT_LEFT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 9
	je	SHORT $LN5@genMainAST

; 334  : 		{
; 335  : 			printf("[SYNTAX ERROR] '(' is missing in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
	call	_printf
	add	esp, 8

; 336  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@genMainAST:

; 337  : 		}
; 338  : 		left = binexpr(BINEXPR_PTP_STARTVAL, TT_OP_END);

	push	6
	push	0
	call	_binexpr
	add	esp, 8
	mov	DWORD PTR _left$[ebp], eax

; 339  : 		node = mkastnode(t->tokenType, t->intValue, t->floatVal, left, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+24]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 340  : 		scan_curToken();

	call	_scan_curToken

; 341  : 		if (currentToken->tokenType != TT_OP_END)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 6
	je	SHORT $LN6@genMainAST

; 342  : 		{
; 343  : 			printf("[SYNTAX ERROR] expected an ';' in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CL@ODPNLPMO@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5?8?$DL?8?5@
	call	_printf
	add	esp, 8

; 344  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@genMainAST:

; 345  : 		}
; 346  : 		break;

	jmp	$LN2@genMainAST
$LN7@genMainAST:

; 347  : 
; 348  : 	case TT_VAR:
; 349  : 		node = genVarAST();

	call	_genVarAST
	mov	DWORD PTR _node$[ebp], eax

; 350  : 		node->right = genMainAST(scope_depth, SCOPE_MODE_DEFAULT, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _scope_depth$[ebp]
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 351  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST
$LN8@genMainAST:

; 352  : 
; 353  : 	case TT_IDENT:
; 354  : 		node = genIdentAST();

	call	_genIdentAST
	mov	DWORD PTR _node$[ebp], eax

; 355  : 		node->right = genMainAST(scope_depth, SCOPE_MODE_DEFAULT, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _scope_depth$[ebp]
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 356  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST
$LN9@genMainAST:

; 357  : 
; 358  : 	case TT_UNDEF:
; 359  : 		scan_curToken();

	call	_scan_curToken

; 360  : 		if (currentToken->tokenType != TT_IDENT)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 18			; 00000012H
	je	SHORT $LN10@genMainAST

; 361  : 		{
; 362  : 			printf("[SYNTAX ERROR] expected an identifier (Line %d)\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0DB@LJCGOJNF@?$FLSYNTAX?5ERROR?$FN?5expected?5an?5iden@
	call	_printf
	add	esp, 8

; 363  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@genMainAST:

; 364  : 		}
; 365  : 		char* varName_save = calloc(strlen(currentToken->IdentToken_name), sizeof(char));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _varName_save$1[ebp], eax

; 366  : 		varName_save = strcpy(varName_save, currentToken->IdentToken_name);

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _varName_save$1[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	DWORD PTR _varName_save$1[ebp], eax

; 367  : 		left = mkastnode_ident(TT_IDENT, currentToken->intValue, currentToken->floatVal, NULL, NULL, NULL, varName_save, NULL);

	push	0
	mov	eax, DWORD PTR _varName_save$1[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _currentToken
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+24]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _currentToken
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	push	ecx
	push	18					; 00000012H
	call	_mkastnode_ident
	add	esp, 40					; 00000028H
	mov	DWORD PTR _left$[ebp], eax

; 368  : 		scan_curToken();

	call	_scan_curToken

; 369  : 		if (currentToken->tokenType != TT_OP_END)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 6
	je	SHORT $LN11@genMainAST

; 370  : 		{
; 371  : 			printf("[SYNTAX ERROR] expected a ';' in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
	call	_printf
	add	esp, 8

; 372  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@genMainAST:

; 373  : 		}
; 374  : 		right = genMainAST(scope_depth, scope_mode, 0);

	push	0
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scope_depth$[ebp]
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _right$[ebp], eax

; 375  : 		node = mkastnode(TT_UNDEF, 0, 0, left, right, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	21					; 00000015H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 376  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST
$LN12@genMainAST:

; 377  : 
; 378  : 
; 379  : 
; 380  : 
; 381  : 	case TT_IF:
; 382  : 		scan_curToken();

	call	_scan_curToken

; 383  : 		if (currentToken->tokenType != TT_LEFT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 9
	je	SHORT $LN13@genMainAST

; 384  : 		{
; 385  : 			printf("[SYNTAX ERROR] '(' is missing in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
	call	_printf
	add	esp, 8

; 386  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@genMainAST:

; 387  : 		}
; 388  : 		node = mkastnode(TT_IF, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	8
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 389  : 		node->left = mkastnode(TT_ANY_OP, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	25					; 00000019H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 390  : 		node->left->left = binexpr(0, TT_LEFT_CURLY);

	push	11					; 0000000bH
	push	0
	call	_binexpr
	add	esp, 8
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax

; 391  : 		node->left->right = genMainAST(scope_depth, SCOPE_MODE_STATEMENT, 0);

	push	0
	push	1
	mov	eax, DWORD PTR _scope_depth$[ebp]
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+24], eax

; 392  : 		node->right = genMainAST(scope_depth, scope_mode, 1);

	push	1
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scope_depth$[ebp]
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+24], eax

; 393  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST

; 394  : 		break;

	jmp	$LN2@genMainAST
$LN14@genMainAST:

; 395  :      
; 396  : 	case TT_ELIF:
; 397  : 		scan_curToken();

	call	_scan_curToken

; 398  : 		if (currentToken->tokenType != TT_LEFT_PAREN)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 9
	je	SHORT $LN15@genMainAST

; 399  : 		{
; 400  : 			printf("[SYNTAX ERROR] '(' is missing in Line %d\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CK@IKFFBBDD@?$FLSYNTAX?5ERROR?$FN?5?8?$CI?8?5is?5missing?5i@
	call	_printf
	add	esp, 8

; 401  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@genMainAST:

; 402  : 		}
; 403  : 		if (if_init == 0)

	cmp	DWORD PTR _if_init$[ebp], 0
	jne	SHORT $LN16@genMainAST

; 404  : 		{
; 405  : 			printf("[ERROR] you cannot have an 'elif' statement without an 'if' statement (Line %d) \n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0FC@IKOHCIDM@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8eli@
	call	_printf
	add	esp, 8

; 406  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@genMainAST:

; 407  : 		}
; 408  : 		node = mkastnode(TT_ELIF, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	35					; 00000023H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 409  : 		node->left = mkastnode(TT_ANY_OP, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	25					; 00000019H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 410  : 		node->left->left = binexpr(0, TT_LEFT_CURLY);

	push	11					; 0000000bH
	push	0
	call	_binexpr
	add	esp, 8
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], eax

; 411  : 		node->left->right = genMainAST(scope_depth, SCOPE_MODE_STATEMENT, 0);

	push	0
	push	1
	mov	eax, DWORD PTR _scope_depth$[ebp]
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+24], eax

; 412  : 		node->right = genMainAST(scope_depth, scope_mode, 1);

	push	1
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scope_depth$[ebp]
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+24], eax

; 413  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST

; 414  : 		break;

	jmp	$LN2@genMainAST
$LN17@genMainAST:

; 415  : 
; 416  : 	case TT_ELSE:
; 417  : 		if (if_init == 0)

	cmp	DWORD PTR _if_init$[ebp], 0
	jne	SHORT $LN18@genMainAST

; 418  : 		{
; 419  : 			printf("[ERROR] you cannot have an 'else' statement without an 'if' statement (Line %d) \n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0FC@OLDPBKN@?$FLERROR?$FN?5you?5cannot?5have?5an?5?8els@
	call	_printf
	add	esp, 8

; 420  : 			exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@genMainAST:

; 421  : 		}
; 422  : 		node = mkastnode(TT_ELSE, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	36					; 00000024H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 423  : 		node->left = mkastnode(TT_ANY_OP, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	25					; 00000019H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 424  : 		node->left->left = NULL;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], 0

; 425  : 		node->left->right = genMainAST(scope_depth, SCOPE_MODE_STATEMENT, 0);

	push	0
	push	1
	mov	eax, DWORD PTR _scope_depth$[ebp]
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+24], eax

; 426  : 		node->right = genMainAST(scope_depth, scope_mode, 0);

	push	0
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scope_depth$[ebp]
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+24], eax

; 427  : 		return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST

; 428  : 		break;

	jmp	$LN2@genMainAST
$LN19@genMainAST:

; 429  : 
; 430  : 
; 431  : 
; 432  : 
; 433  : 	///////////////////////////////////////////////////////////////////
; 434  : 	//    SCOPE
; 435  : 	///////////////////////////////////////////////////////////////////
; 436  :     
; 437  : 	// todo: add error messages for scope
; 438  : 
; 439  : 	case TT_LEFT_CURLY:
; 440  : 		globl_open_curly_count++;

	mov	eax, DWORD PTR _globl_open_curly_count
	add	eax, 1
	mov	DWORD PTR _globl_open_curly_count, eax

; 441  : 		globl_current_depth = globl_open_curly_count - globl_closed_curly_count;

	mov	eax, DWORD PTR _globl_open_curly_count
	sub	eax, DWORD PTR _globl_closed_curly_count
	mov	DWORD PTR _globl_current_depth, eax

; 442  : 		if (globl_current_depth == (scope_depth + 1))

	mov	eax, DWORD PTR _scope_depth$[ebp]
	add	eax, 1
	cmp	DWORD PTR _globl_current_depth, eax
	jne	SHORT $LN20@genMainAST

; 443  : 		{
; 444  : 			node = mkastnode(TT_SCOPE, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	33					; 00000021H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 445  : 			node->left = genMainAST(globl_current_depth, SCOPE_MODE_DEFAULT, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _globl_current_depth
	push	eax
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 446  : 			if (scope_mode == SCOPE_MODE_DEFAULT)

	cmp	DWORD PTR _scope_mode$[ebp], 0
	jne	SHORT $LN21@genMainAST

; 447  : 			{
; 448  : 				node->right = genMainAST(globl_current_depth, scope_mode, 0);

	push	0
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _globl_current_depth
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN21@genMainAST:

; 449  : 			}
; 450  : 			return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	$LN1@genMainAST
$LN20@genMainAST:

; 451  : 		}
; 452  : 		break;

	jmp	SHORT $LN2@genMainAST
$LN22@genMainAST:

; 453  : 
; 454  : 	case TT_RIGHT_CURLY:
; 455  : 		globl_closed_curly_count++;

	mov	eax, DWORD PTR _globl_closed_curly_count
	add	eax, 1
	mov	DWORD PTR _globl_closed_curly_count, eax

; 456  : 		globl_current_depth = globl_open_curly_count - globl_closed_curly_count;

	mov	eax, DWORD PTR _globl_open_curly_count
	sub	eax, DWORD PTR _globl_closed_curly_count
	mov	DWORD PTR _globl_current_depth, eax

; 457  : 		if (globl_current_depth == (scope_depth -1))

	mov	eax, DWORD PTR _scope_depth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _globl_current_depth, eax
	jne	SHORT $LN23@genMainAST

; 458  : 		{
; 459  : 			globl_open_curly_count -= 1;

	mov	eax, DWORD PTR _globl_open_curly_count
	sub	eax, 1
	mov	DWORD PTR _globl_open_curly_count, eax

; 460  : 			globl_closed_curly_count -= 1;

	mov	eax, DWORD PTR _globl_closed_curly_count
	sub	eax, 1
	mov	DWORD PTR _globl_closed_curly_count, eax

; 461  : 			node = mkastnode(TT_SCOPE_END, 0, 0, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	34					; 00000022H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 462  : 			return node;

	mov	eax, DWORD PTR _node$[ebp]
	jmp	SHORT $LN1@genMainAST
$LN23@genMainAST:
$LN2@genMainAST:

; 463  : 		}
; 464  : 		break;
; 465  : 
; 466  : 	/////////////////////////////////////////////////////////////////////
; 467  : 
; 468  : 
; 469  : 	}
; 470  : 	if (currentToken->tokenType == TT_EOF)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN24@genMainAST

; 471  : 	{
; 472  : 		right = NULL;

	mov	DWORD PTR _right$[ebp], 0

; 473  : 	}

	jmp	SHORT $LN25@genMainAST
$LN24@genMainAST:

; 474  : 	else
; 475  : 	{
; 476  : 		right = genMainAST(scope_depth, scope_mode, 0);

	push	0
	mov	eax, DWORD PTR _scope_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scope_depth$[ebp]
	push	ecx
	call	_genMainAST
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _right$[ebp], eax
$LN25@genMainAST:

; 477  : 	}
; 478  : 	node = mkastnode(t->tokenType, t->intValue, t->floatVal, left, right, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _t$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+24]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _node$[ebp], eax

; 479  : 	return node;

	mov	eax, DWORD PTR _node$[ebp]
$LN1@genMainAST:

; 480  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@genMainAST:
	DD	$LN4@genMainAST
	DD	$LN12@genMainAST
	DD	$LN19@genMainAST
	DD	$LN22@genMainAST
	DD	$LN8@genMainAST
	DD	$LN7@genMainAST
	DD	$LN9@genMainAST
	DD	$LN14@genMainAST
	DD	$LN17@genMainAST
	DD	$LN2@genMainAST
$LN27@genMainAST:
	DB	0
	DB	1
	DB	9
	DB	9
	DB	2
	DB	3
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	5
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	8
_genMainAST ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _binexpr
_TEXT	SEGMENT
_saveIdentName$1 = -128					; size = 4
_lastToken$2 = -116					; size = 4
_lastLine$ = -104					; size = 4
_boolVal$3 = -92					; size = 4
_boolVal$4 = -80					; size = 4
_saveIdentName$5 = -68					; size = 4
_minusToken$ = -56					; size = 4
_minusVal$ = -44					; size = 4
_right$ = -32						; size = 4
_left$ = -20						; size = 4
_k$ = -8						; size = 4
_ptp$ = 8						; size = 4
_interrupt_token$ = 12					; size = 4
_binexpr PROC						; COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 210  : 	int k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 211  : 	struct  AST_Node* left, * right;
; 212  : 	scan_curToken(); // int or float

	call	_scan_curToken

; 213  : 	int minusVal = 1;

	mov	DWORD PTR _minusVal$[ebp], 1

; 214  : 	struct Token* minusToken = currentToken;

	mov	eax, DWORD PTR _currentToken
	mov	DWORD PTR _minusToken$[ebp], eax
$LN2@binexpr:

; 215  : 	while (currentToken->tokenType == TT_MINUS)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@binexpr

; 216  : 	{
; 217  : 		minusVal *= -1;

	imul	eax, DWORD PTR _minusVal$[ebp], -1
	mov	DWORD PTR _minusVal$[ebp], eax

; 218  : 		scan_curToken();

	call	_scan_curToken

; 219  : 	}

	jmp	SHORT $LN2@binexpr
$LN3@binexpr:

; 220  : 	leftParenCode(minusToken);

	mov	eax, DWORD PTR _minusToken$[ebp]
	push	eax
	call	_leftParenCode
	add	esp, 4

; 221  : 
; 222  : 	if (currentToken->tokenType != TT_INT && currentToken->tokenType != TT_FLOAT && currentToken->tokenType != TT_IDENT && currentToken->tokenType != TT_BOOL_TRUE && currentToken->tokenType != TT_BOOL_FALSE)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 5
	je	SHORT $LN6@binexpr
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 16			; 00000010H
	je	SHORT $LN6@binexpr
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 18			; 00000012H
	je	SHORT $LN6@binexpr
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 31			; 0000001fH
	je	SHORT $LN6@binexpr
	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 32			; 00000020H
	je	SHORT $LN6@binexpr

; 223  : 	{
; 224  : 		printf("[SYNTAX ERROR] expected a number (Line %d)", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0CL@IONHGKCI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5numbe@
	call	_printf
	add	esp, 8

; 225  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@binexpr:

; 226  : 	}
; 227  : 	if (currentToken->data != NULL)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN7@binexpr

; 228  : 	{
; 229  : 		currentToken->data->minusVal = minusVal;

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _minusVal$[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN7@binexpr:

; 230  : 	}
; 231  : 	left = mkastnode_const(currentToken->tokenType, currentToken->intValue * minusVal, currentToken->floatVal * minusVal, NULL, currentToken->data);

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	0
	cvtsi2sd xmm0, DWORD PTR _minusVal$[ebp]
	mov	edx, DWORD PTR _currentToken
	mulsd	xmm0, QWORD PTR [edx+24]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _minusVal$[ebp]
	cdq
	mov	ecx, DWORD PTR _currentToken
	push	edx
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	call	__allmul
	push	edx
	push	eax
	mov	ecx, DWORD PTR _currentToken
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_mkastnode_const
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _left$[ebp], eax

; 232  : 	if (currentToken->tokenType == TT_IDENT)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 18			; 00000012H
	jne	$LN8@binexpr

; 233  : 	{
; 234  : 		char* saveIdentName = calloc(strlen(currentToken->IdentToken_name), sizeof(char));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _saveIdentName$5[ebp], eax

; 235  : 		saveIdentName = strcpy(saveIdentName, currentToken->IdentToken_name);

	mov	eax, DWORD PTR _currentToken
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _saveIdentName$5[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	DWORD PTR _saveIdentName$5[ebp], eax

; 236  : 		left = mkastnode_ident(TT_IDENT, minusVal, minusVal, NULL, NULL, newID_token(DT_INT, 1, 0, saveIdentName, 0, new_DATA_STRUCT(NULL, NULL, NULL, NULL, NULL, -1, minusVal)), saveIdentName, NULL);

	push	0
	mov	eax, DWORD PTR _saveIdentName$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _minusVal$[ebp]
	push	ecx
	push	-1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	mov	edx, DWORD PTR _saveIdentName$5[ebp]
	push	edx
	push	0
	push	0
	push	1
	push	0
	call	_newID_token
	add	esp, 28					; 0000001cH
	push	eax
	push	0
	push	0
	cvtsi2sd xmm0, DWORD PTR _minusVal$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _minusVal$[ebp]
	cdq
	push	edx
	push	eax
	push	18					; 00000012H
	call	_mkastnode_ident
	add	esp, 40					; 00000028H
	mov	DWORD PTR _left$[ebp], eax
$LN8@binexpr:

; 237  : 	}
; 238  : 	if (currentToken->tokenType == TT_BOOL_TRUE)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 31			; 0000001fH
	jne	SHORT $LN9@binexpr

; 239  : 	{
; 240  : 		int* boolVal = malloc(sizeof(int));

	mov	esi, esp
	push	4
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _boolVal$4[ebp], eax

; 241  : 		*boolVal = 1;

	mov	eax, DWORD PTR _boolVal$4[ebp]
	mov	DWORD PTR [eax], 1

; 242  : 		left = mkastnode(TT_BOOL_TRUE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, boolVal, NULL, NULL, NULL, DT_BOOL, 1));

	push	1
	push	5
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _boolVal$4[ebp]
	push	eax
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	31					; 0000001fH
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _left$[ebp], eax
$LN9@binexpr:

; 243  : 	}
; 244  : 	if (currentToken->tokenType == TT_BOOL_FALSE)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	SHORT $LN10@binexpr

; 245  : 	{
; 246  : 		int* boolVal = malloc(sizeof(int));

	mov	esi, esp
	push	4
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _boolVal$3[ebp], eax

; 247  : 		*boolVal = 0;

	mov	eax, DWORD PTR _boolVal$3[ebp]
	mov	DWORD PTR [eax], 0

; 248  : 		left = mkastnode(TT_BOOL_FALSE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, boolVal, NULL, NULL, NULL, DT_BOOL, 1));

	push	1
	push	5
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _boolVal$3[ebp]
	push	eax
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	32					; 00000020H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _left$[ebp], eax
$LN10@binexpr:

; 249  : 	}
; 250  : 	minusVal = 1;

	mov	DWORD PTR _minusVal$[ebp], 1

; 251  : 	int lastLine = Line;

	mov	eax, DWORD PTR _Line
	mov	DWORD PTR _lastLine$[ebp], eax

; 252  : 	scan_curToken(); // bin operator

	call	_scan_curToken

; 253  : 
; 254  : 
; 255  : 
; 256  : 	if (rightParenCode(interrupt_token) == 1)

	mov	eax, DWORD PTR _interrupt_token$[ebp]
	push	eax
	call	_rightParenCode
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN11@binexpr

; 257  : 	{
; 258  : 		return left;

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@binexpr
$LN11@binexpr:

; 259  : 	}
; 260  : 
; 261  : 
; 262  : 	if (tokenIsBinOp(currentToken) == 0)

	mov	eax, DWORD PTR _currentToken
	push	eax
	call	_tokenIsBinOp
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN12@binexpr

; 263  : 	{
; 264  : 		printf("[SYNTAX ERROR] expected a binary operator or ';' (Line %d)\n", lastLine);

	mov	eax, DWORD PTR _lastLine$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@DMODEJOA@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5binar@
	call	_printf
	add	esp, 8

; 265  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@binexpr:

; 266  : 	}
; 267  : 	if (currentToken->tokenType == TT_EOF)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 17			; 00000011H
	jne	SHORT $LN13@binexpr

; 268  : 	{
; 269  : 		printf("[SYNTAX ERROR] expected a ';' in Line %d\n", lastLine);

	mov	eax, DWORD PTR _lastLine$[ebp]
	push	eax
	push	OFFSET ??_C@_0CK@CCJBDENI@?$FLSYNTAX?5ERROR?$FN?5expected?5a?5?8?$DL?8?5i@
	call	_printf
	add	esp, 8

; 270  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN13@binexpr:

; 271  : 	}
; 272  : 	if (currentToken->tokenType == TT_OP_END)

	mov	eax, DWORD PTR _currentToken
	cmp	DWORD PTR [eax], 6
	jne	SHORT $LN14@binexpr

; 273  : 	{
; 274  : 		if (interrupt_token == INTERRUPT_TOKEN_DEFAULT)

	cmp	DWORD PTR _interrupt_token$[ebp], -1
	jne	SHORT $LN15@binexpr

; 275  : 		{
; 276  : 			return left;

	mov	eax, DWORD PTR _left$[ebp]
	jmp	$LN1@binexpr
$LN15@binexpr:

; 277  : 		}
; 278  : 		printf("[SYNTAX ERROR] cannot use ';' inside an expression (Line %d)\n", Line);

	mov	eax, DWORD PTR _Line
	push	eax
	push	OFFSET ??_C@_0DO@IELMIDFA@?$FLSYNTAX?5ERROR?$FN?5cannot?5use?5?8?$DL?8?5i@
	call	_printf
	add	esp, 8

; 279  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@binexpr:

; 280  : 	}
; 281  : 
; 282  : 	while (getOpPrecedence(currentToken) + globl_inParen * globl_parenDelta > ptp)

	mov	eax, DWORD PTR _currentToken
	push	eax
	call	_getOpPrecedence
	add	esp, 4
	mov	ecx, DWORD PTR _globl_inParen
	imul	ecx, DWORD PTR _globl_parenDelta
	add	eax, ecx
	cmp	eax, DWORD PTR _ptp$[ebp]
	jle	$LN5@binexpr

; 283  : 	{
; 284  : 		struct Token* lastToken = currentToken;

	mov	eax, DWORD PTR _currentToken
	mov	DWORD PTR _lastToken$2[ebp], eax

; 285  : 		right = binexpr(getOpPrecedence(currentToken) + globl_inParen * globl_parenDelta, interrupt_token);

	mov	eax, DWORD PTR _interrupt_token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _currentToken
	push	ecx
	call	_getOpPrecedence
	add	esp, 4
	mov	edx, DWORD PTR _globl_inParen
	imul	edx, DWORD PTR _globl_parenDelta
	add	eax, edx
	push	eax
	call	_binexpr
	add	esp, 8
	mov	DWORD PTR _right$[ebp], eax

; 286  : 		left = mkastnode(lastToken->tokenType, lastToken->intValue, lastToken->floatVal, left, right, NULL, lastToken->data);

	mov	eax, DWORD PTR _lastToken$2[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	0
	mov	edx, DWORD PTR _right$[ebp]
	push	edx
	mov	eax, DWORD PTR _left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lastToken$2[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+24]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _lastToken$2[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	edx, DWORD PTR _lastToken$2[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _left$[ebp], eax

; 287  : 		if (lastToken->tokenType == TT_IDENT)

	mov	eax, DWORD PTR _lastToken$2[ebp]
	cmp	DWORD PTR [eax], 18			; 00000012H
	jne	$LN16@binexpr

; 288  : 		{
; 289  : 			char* saveIdentName = calloc(strlen(lastToken->IdentToken_name), sizeof(char));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _lastToken$2[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _saveIdentName$1[ebp], eax

; 290  : 			saveIdentName = strcpy(saveIdentName, lastToken->IdentToken_name);

	mov	eax, DWORD PTR _lastToken$2[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _saveIdentName$1[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	DWORD PTR _saveIdentName$1[ebp], eax

; 291  : 			left = mkastnode_ident(lastToken->tokenType, lastToken->intValue, lastToken->floatVal, left, right, newID_token(DT_INT, 1, 0, saveIdentName, 0, new_DATA_STRUCT(NULL, NULL, NULL, NULL, NULL, -1, minusVal)), saveIdentName, NULL);

	push	0
	mov	eax, DWORD PTR _saveIdentName$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _minusVal$[ebp]
	push	ecx
	push	-1
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	mov	edx, DWORD PTR _saveIdentName$1[ebp]
	push	edx
	push	0
	push	0
	push	1
	push	0
	call	_newID_token
	add	esp, 28					; 0000001cH
	push	eax
	mov	eax, DWORD PTR _right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _left$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lastToken$2[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+24]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _lastToken$2[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	push	edx
	mov	eax, DWORD PTR _lastToken$2[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_mkastnode_ident
	add	esp, 40					; 00000028H
	mov	DWORD PTR _left$[ebp], eax
$LN16@binexpr:

; 292  : 		}
; 293  : 		if (lastToken->tokenType == TT_BOOL_TRUE)

	mov	eax, DWORD PTR _lastToken$2[ebp]
	cmp	DWORD PTR [eax], 31			; 0000001fH
	jne	SHORT $LN17@binexpr

; 294  : 		{
; 295  : 			left = mkastnode(TT_BOOL_TRUE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, 1, NULL, NULL, NULL, DT_BOOL, 1));

	push	1
	push	5
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	31					; 0000001fH
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _left$[ebp], eax
$LN17@binexpr:

; 296  : 		}
; 297  : 		if (lastToken->tokenType == TT_BOOL_FALSE)

	mov	eax, DWORD PTR _lastToken$2[ebp]
	cmp	DWORD PTR [eax], 32			; 00000020H
	jne	SHORT $LN18@binexpr

; 298  : 		{
; 299  : 			left = mkastnode(TT_BOOL_FALSE, 0, 0, NULL, NULL, NULL, new_DATA_STRUCT(NULL, 0, NULL, NULL, NULL, DT_BOOL, 1));

	push	1
	push	5
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	_new_DATA_STRUCT
	add	esp, 32					; 00000020H
	push	eax
	push	0
	push	0
	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	32					; 00000020H
	call	_mkastnode
	add	esp, 36					; 00000024H
	mov	DWORD PTR _left$[ebp], eax
$LN18@binexpr:

; 300  : 		}
; 301  : 
; 302  : 		rightParenCode(interrupt_token);

	mov	eax, DWORD PTR _interrupt_token$[ebp]
	push	eax
	call	_rightParenCode
	add	esp, 4

; 303  : 	}

	jmp	$LN14@binexpr
$LN5@binexpr:

; 304  : 	return left;

	mov	eax, DWORD PTR _left$[ebp]
$LN1@binexpr:

; 305  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_binexpr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_ident
_TEXT	SEGMENT
_initNode$ = -8						; size = 4
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_right$ = 32						; size = 4
_otherData$ = 36					; size = 4
_varName$ = 40						; size = 4
_data$ = 44						; size = 4
_mkastnode_ident PROC					; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 194  : 	struct AST_Node* initNode = malloc(sizeof(struct AST_Node));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initNode$[ebp], eax

; 195  : 	initNode->tokenType = tokenType;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 196  : 	initNode->intVal = intVal;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _intVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _intVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 197  : 	initNode->floatVal = floatVal;

	mov	eax, DWORD PTR _initNode$[ebp]
	movsd	xmm0, QWORD PTR _floatVal$[ebp]
	movsd	QWORD PTR [eax+8], xmm0

; 198  : 	initNode->left = left;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 199  : 	initNode->right = right;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 200  : 	initNode->otherData = otherData;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _otherData$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 201  : 	initNode->varName = varName;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _varName$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 202  : 	initNode->data = data;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 203  : 	return initNode;

	mov	eax, DWORD PTR _initNode$[ebp]

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mkastnode_ident ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_left
_TEXT	SEGMENT
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_otherData$ = 32					; size = 4
_data$ = 36						; size = 4
_mkastnode_left PROC					; COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 188  : 	return(mkastnode(tokenType, intVal, floatVal, left, NULL, otherData, data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _otherData$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _left$[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _floatVal$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _intVal$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _intVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tokenType$[ebp]
	push	edx
	call	_mkastnode
	add	esp, 36					; 00000024H

; 189  : 
; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mkastnode_left ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode_const
_TEXT	SEGMENT
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_otherData$ = 28					; size = 4
_data$ = 32						; size = 4
_mkastnode_const PROC					; COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 183  : 	return(mkastnode(tokenType, intVal, floatVal, NULL, NULL, otherData, data));

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _otherData$[ebp]
	push	ecx
	push	0
	push	0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _floatVal$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _intVal$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _intVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tokenType$[ebp]
	push	ecx
	call	_mkastnode
	add	esp, 36					; 00000024H

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mkastnode_const ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\genAST.c
;	COMDAT _mkastnode
_TEXT	SEGMENT
_initNode$ = -8						; size = 4
_tokenType$ = 8						; size = 4
_intVal$ = 12						; size = 8
_floatVal$ = 20						; size = 8
_left$ = 28						; size = 4
_right$ = 32						; size = 4
_otherData$ = 36					; size = 4
_data$ = 40						; size = 4
_mkastnode PROC						; COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __B5AFADD0_genAST@c
	call	@__CheckForDebuggerJustMyCode@4

; 168  : 	struct AST_Node* initNode = malloc(sizeof(struct AST_Node));

	mov	esi, esp
	push	40					; 00000028H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _initNode$[ebp], eax

; 169  : 	initNode->tokenType = tokenType;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _tokenType$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 170  : 	initNode->intVal = intVal;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _intVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _intVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 171  : 	initNode->floatVal = floatVal;

	mov	eax, DWORD PTR _initNode$[ebp]
	movsd	xmm0, QWORD PTR _floatVal$[ebp]
	movsd	QWORD PTR [eax+8], xmm0

; 172  : 	initNode->left = left;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 173  : 	initNode->right = right;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 174  : 	initNode->otherData = otherData;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _otherData$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 175  : 	initNode->varName = NULL;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	DWORD PTR [eax+32], 0

; 176  : 	initNode->data = data;

	mov	eax, DWORD PTR _initNode$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 177  : 	return initNode;

	mov	eax, DWORD PTR _initNode$[ebp]

; 178  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mkastnode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\leonf\Desktop\vsCode\c\Interpreter\Interpreter_github\Interpreter\src\header\tokens.h
;	COMDAT _new_DATA_STRUCT
_TEXT	SEGMENT
_init$ = -8						; size = 4
_strVal$ = 8						; size = 4
_boolVal$ = 12						; size = 4
_doubleVal$ = 16					; size = 4
_intVal$ = 20						; size = 8
_charVal$ = 28						; size = 4
_dataType$ = 32						; size = 4
_minusVal$ = 36						; size = 4
_new_DATA_STRUCT PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8478A1A4_tokens@h
	call	@__CheckForDebuggerJustMyCode@4

; 29   : 	struct DATA_STRUCT* init = malloc(sizeof(struct DATA_STRUCT));

	mov	esi, esp
	push	28					; 0000001cH
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _init$[ebp], eax

; 30   : 	init->strVal = strVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _strVal$[ebp]
	mov	DWORD PTR [eax], ecx

; 31   : 	init->boolVal = boolVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _boolVal$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 32   : 	init->doubleVal = doubleVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _doubleVal$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 33   : 	init->intVal = intVal;

	mov	eax, DWORD PTR _intVal$[ebp]
	mov	ecx, DWORD PTR _init$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 34   : 	init->charVal = charVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _charVal$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 35   : 	init->dataType = dataType;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _dataType$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 36   : 	init->minusVal = minusVal;

	mov	eax, DWORD PTR _init$[ebp]
	mov	ecx, DWORD PTR _minusVal$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 37   : 	return init;

	mov	eax, DWORD PTR _init$[ebp]

; 38   : };

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_new_DATA_STRUCT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 961  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
